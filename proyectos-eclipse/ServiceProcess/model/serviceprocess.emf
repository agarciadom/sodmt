@namespace(uri="http://www.uca.es/modeling/serviceProcess", prefix="sp")
package serviceProcess;

@gmf.diagram(foo="bar")
class ServiceProcess {
  val Activity[*] activity;
  val ActivityEdge[*] edge;
  val Annotation[*] annotations;
}

@gmf.node(label="name")
abstract class NamedElement {
   attr String name;
}

abstract class Activity {
  @gmf.compartment(layout="free")
  val ActivityNode[*]#activity nodes;
}

abstract class ActivityNode {
  ref Activity#nodes activity;
  ref ActivityEdge[*]#target incoming;
  ref ActivityEdge[*]#source outgoing;
}

@gmf.link(source="source", target="target", target.decoration="arrow", width="3")
abstract class ActivityEdge {
  ref ActivityNode#incoming target;
  ref ActivityNode#outgoing source;
  @gmf.link(label="condition", style="dash", tool.name="Link Edge Condition")
  ref EdgeCondition#edge condition;
}

abstract class Annotation {
   @gmf.label(label.readOnly="true")
   attr boolean manuallyAdded = true;
}

/* ANNOTATIONS */

/* condition = 'else' -> default flow */
@gmf.node(label="condition",
          label.pattern="<<condition>>",
          figure="rectangle",
          tool.name="Edge Condition")
class EdgeCondition extends Annotation {
    ref ControlNodeEdge#condition edge;

    @gmf.label(foo="bar")
    attr String condition = "true";
    @gmf.label(foo="bar")
    attr ExpressionLanguage language;
    @gmf.label(foo="bar")
    attr Double probability = 1;
}

@gmf.node(label="transactionsPerSec",
          label.pattern="<<performance>>",
          figure="rectangle",
          tool.name="Performance Constraint")
class PerformanceAnnotation extends Annotation {
   ref ExecutableNode#annotation execNode;

   @gmf.label(foo="bar")
   attr Long transactionsPerSec = 1;
   @gmf.label(foo="bar")
   attr Double secsTimeLimit = 1;
}

/* ACTIVITIES */

@gmf.node(tool.name="Service Activity")
class ServiceActivity extends Activity, NamedElement {
  @gmf.label(foo="bar")
  attr Long transactionsPerSec = 1;
  @gmf.label(foo="bar")
  attr Double secsTimeLimit = 1;
}

/* EDGES */

@gmf.link(style="dash",target.decoration="arrow",tool.name="Object Flow")
class ObjectFlow extends ActivityEdge {
}

@gmf.link(target.decoration="arrow", tool.name="Control Flow")
class ControlFlow extends ActivityEdge {
}

/* NODES */

abstract class ControlNode extends ActivityNode {
}

@gmf.node(figure="figures.LabeledEllipse", label.icon="false",
          tool.name="Executable Node")
class ExecutableNode extends ControlNode, NamedElement {
  @gmf.link(label="performance", style="dash",
            tool.name="Link Performance Annotation")
  ref PerformanceAnnotation#execNode annotation;
}

@gmf.node(figure="figures.FgBgFilledCircleFigure", border.color="0,0,0",
          size="30,30", tool.name="Start")
class InitialNode extends ControlNode {
}

@gmf.node(figure="figures.FgFilledCircleFigure", border.color="0,0,0",
          size="30,30", tool.name="Finish")
class FinalNode extends ControlNode {
}

@gmf.node(figure="figures.FgFilledRectangleFigure", border.color="0,0,0",
          size="15,30", tool.name="Fork")
class ForkNode extends ControlNode {
}

@gmf.node(figure="figures.FgFilledRectangleFigure", border.color="0,0,0",
          size="15,30", tool.name="Join")
class JoinNode extends ControlNode {
}

@gmf.node(figure="figures.DiamondFigure", border.color="0,0,0", size="30,30",
          tool.name="Decision")
class DecisionNode extends ControlNode {
}

/* DATATYPES */

enum ExpressionLanguage {
   OCL;
   JML;
}

/* Visit status for nodes: needed for the colored depth-first search
   used to detect cycles in the graph in the EVL script. */
enum VisitStatus {
   NOT_VISITED;
   VISITING;
   VISITED;
}

/* Node side: useful for operations which need to distinguish between the
   incoming side and the outgoing side */
enum NodeSide {
   INCOMING;
   OUTGOING;
}
