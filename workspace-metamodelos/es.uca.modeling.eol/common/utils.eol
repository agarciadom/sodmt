-- PERFORMANCE ANNOTATIONS ----------------------------------------------------

operation FlowNode hasManualPerformanceAnnotation() : Boolean {
  return self.hasProperty('annotation') and self.annotation.isDefined() and self.annotation.manuallyAdded;
}

operation FlowNode hasAutomaticPerformanceAnnotation() : Boolean {
  return self.hasProperty('annotation') and self.annotation.isDefined() and not self.annotation.manuallyAdded;
}

-- Returns the weight of this node, or the default value if it has not been set.
-- TODO: extend the model to allow the user to define the weight.
operation Activity getWeight() : Real {
  return 1.0d;
}

-- Returns the time limit for this node, be it either manual or automatic, if set.
$pre self.annotation.isDefined()
operation Activity getTimeLimit() : Real {
  return self.annotation.secsTimeLimit;
}

-- Sets an automatic time limit restriction for this node. Restrictions can only
-- be made stricter, and not relaxed.
$pre self.annotation.isUndefined() or (not self.annotation.manuallyAdded and self.annotation.secsTimeLimit >= newLimit)
operation Activity setTimeLimit(newLimit : Real) {
  if (self.annotation.isUndefined()) {
    self.createPerformanceAnnotation();
  }
  self.annotation.secsTimeLimit := newLimit;
}

-- GRAPH PREPROCESSING --------------------------------------------------------

@cached
$post _result >= 0
operation FlowNode getDepth() : Integer {
  if (self.incoming.isEmpty()) {
    return 0;
  }
  else {
    return self.incoming.collect(r|r.source.getDepth()).max() + 1;
  }
}

-- LOWEST COMMON ANCESTOR -----------------------------------------------------

@cached
$pre nodeA.getDepth().isDefined() and nodeB.getDepth().isDefined()
operation getLCA(nodeA : FlowNode, nodeB : FlowNode) : FlowNode {
  var depths     := Sequence { nodeA.getDepth(), nodeB.getDepth() };
  var maxDepth   := depths.min();
  var ancestorsA := nodeA.getAncestors(maxDepth);
  var ancestorsB := nodeB.getAncestors(maxDepth);
  var common := ancestorsA.intersect(ancestorsB);

  if (common.isEmpty()) {
    return;
  }

  return common.asSequence().sortBy(r|-r.getDepth()).first();
}

$pre maxDepth >= 0
operation FlowNode getAncestors(maxDepth : Integer) : Set {
  var results := new Set;
  self.addAllAncestors(maxDepth, results);
  --results.println('ancestors of ' + self + ', which has depth = ' + self.getDepth() + ', with maxdepth = ' + maxDepth + ': ');
  return results;
}

$pre maxDepth >= 0 and results.isDefined()
operation FlowNode addAllAncestors(maxDepth : Integer, results : Collection) {
  if (self.getDepth() <= maxDepth) {
    results.add(self);
  }
  for (parent in self.incoming.collect(r|r.source)) {
    parent.addAllAncestors(maxDepth, results);
  }
}

$pre otherSet.isDefined()
operation Set intersect(otherSet : Set) : Set {
  if (otherSet.size() < self.size()) {
    return otherSet.intersect(self);
  }

  var results : Set;
  for (element in self.select(r|otherSet.includes(r))) {
    results.add(element);
  }
  return results;
}

----- ALL PATHS BETWEEN TWO NODES ---------------------------------------------

-- Obtains all the nodes reachable from a node in the graph, in no
-- particular order. Returns a Set: to convert it to a sequence, use asSequence().
-- Note that if you only want the activities, you will need to filter them later
-- on, using select(), for instance.
@cached
operation FlowNode getAllReachableNodes() : Set {
  var nodeSet := new Set;
  nodeSet.add(self);
  addAllReachableNodes(self, nodeSet);
  return nodeSet;
}

-- Adds all the nodes which are reachable from a node in the graph to a set of
-- nodes. Avoids nodes which have been already visited.
operation addAllReachableNodes(node : FlowNode, nodeSet : Set) {
  for (child in node.outgoing.collect(r|r.target)) {
    var oldSize := nodeSet.size();
    nodeSet.add(child);
    if (nodeSet.size() > oldSize) {
      addAllReachableNodes(child, nodeSet);
    }
  }
}

-- Obtains all the paths starting from a node in the graph
-- to every final node (if the starting node is a FinalNode,
-- reports an empty set of paths)
@cached
operation getAllPathsFrom(start : FlowNode) {
  if (start.isKindOf(FinalNode)) {
    return Sequence {};
  }
  else {
    return auxPathsTo(Sequence { start });
  }
}

operation auxPathsTo(partialPath : Sequence) {
  var last_elem := partialPath.last();

  if (last_elem.isKindOf(FinalNode)) {
    return Sequence { partialPath };
  }

  var results := new Sequence;
  for (descendant in last_elem.outgoing.collect(r|r.target)) {
    var newPartialPath := partialPath.clone();
    newPartialPath.add(descendant);
    results.addAll(auxPathsTo(newPartialPath));
  }
  return results;
}

-- UTILITY OPERATIONS FOR VALIDATION --

-- Edge creation

$pre e.isDefined()
operation createEdgeSimilarTo(e : FlowEdge) {
  var utilsTool := new Native('es.uca.modeling.eol.tools.ECoreUtilsTool');
  var newEdge := utilsTool.copy(e);
  addEdge(newEdge);
  return newEdge;
}

-- Adds another node between a node and its direct ancestors or descendants
-- FIXME: Cannot use "NodeSide" as the parameter type (Eclipse Bugzilla #286412)
$pre  newNode.isDefined() and side.isDefined()
$pre  (side = NodeSide#OUTGOING and self.outgoing.size() >= 1) or (side = NodeSide#INCOMING and self.incoming.size() >= 1)
$post (side = NodeSide#OUTGOING and self.outgoing.size() = 1) or (side = NodeSide#INCOMING and self.incoming.size() = 1)
operation FlowNode placeNodeBetween(newNode : FlowNode, side : Any) {
  if (side = NodeSide#OUTGOING) {
    var newEdge := createEdgeSimilarTo(self.outgoing.first());
    for (e in self.outgoing.clone()) {
       e.source := newNode;
    }
    newEdge.source := self;
    newEdge.target := newNode;
  } else {
    var newEdge := createEdgeSimilarTo(self.incoming.first());
    for (e in self.incoming.clone()) {
      e.target := newNode;
    }
    newEdge.source := newNode;
    newEdge.target := self;
  }
}

-- Cycle testing

operation graphIsAcyclic(start : FlowNode) {
  -- Mark all vertices as not visited
  for (v in FlowNode.all) {
    v.~visitStatus := VisitStatus#NOT_VISITED;
  }
  start.~firstEdgeProducingCycle := getFirstEdgeProducingCycle(start);
  return start.~firstEdgeProducingCycle.isUndefined();
}

$pre node.~visitStatus <> VisitStatus#VISITING
operation getFirstEdgeProducingCycle(node : FlowNode) {
  -- All ancestors already visited: nothing to do
  if (node.~visitStatus = VisitStatus#VISITED) {
    return;
  }

  node.~visitStatus := VisitStatus#VISITING;
  for (edge in node.outgoing) {
    if (edge.target.~visitStatus = VisitStatus#VISITING) {
      return edge;
    }

    var firstEdgeProducingCycle := getFirstEdgeProducingCycle(edge.target);
    if (firstEdgeProducingCycle.isDefined()) {
      return firstEdgeProducingCycle;
    }
  }
  node.~visitStatus := VisitStatus#VISITED;
}

-- COMPARISON OF REAL NUMBERS -----------------------------

$pre epsilon > 0
operation isApproximatelyEqual(a : Real, b : Real, epsilon : Real) : Boolean {
  return (a - b).abs() <= epsilon;
}
