rule CopyEAttribute
        transform s : Source!"EAttribute"
        to t : Target!"EAttribute" {
        t."name" := s."name";
        t."ordered" := s."ordered";
        t."unique" := s."unique";
        t."lowerBound" := s."lowerBound";
        t."upperBound" := s."upperBound";
        t."changeable" := s."changeable";
        t."volatile" := s."volatile";
        t."transient" := s."transient";
        t."defaultValueLiteral" := s."defaultValueLiteral";
        t."unsettable" := s."unsettable";
        t."derived" := s."derived";
        t."iD" := s."iD";
        t."eType" ::= s."eType";
        t."eAnnotations" ::= s."eAnnotations";

        -- CUSTOM CODE --------------------------------------------------------
        -- If we use ::= for standard ECore types, we'll get EJavaObjects: bug?
        -- If we always used :=, then we'd depend on the source ECore for our
        -- own customized types. We need to check the type of this attribute to
        -- do The Right Thing (TM).
        if (s.eType.ePackage <> Source!EPackage.all.first()) {
          t.eGenericType := s.eGenericType;
        } else {
          t.eGenericType ::= s.eGenericType;
        }
        -----------------------------------------------------------------------
}

rule CopyEAnnotation
        transform s : Source!"EAnnotation"
        to t : Target!"EAnnotation" {
        t."source" := s."source";
        t."eModelElement" ::= s."eModelElement";
        t."eAnnotations" ::= s."eAnnotations";
        t."details" ::= s."details";
        t."contents" ::= s."contents";
        t."references" ::= s."references";
}

rule CopyEClass
        transform s : Source!"EClass"
        to t : Target!"EClass" {
        if (s.name = 'ServiceProcess') {
          t."name" := 'ServiceComposition';
        } else {
          t.name := s.name;
        }
        t."instanceClassName" := s."instanceClassName";
        t."instanceTypeName" := s."instanceTypeName";
        t."abstract" := s."abstract";
        t."interface" := s."interface";
        t."eAnnotations" ::= s."eAnnotations";
        t."eTypeParameters" ::= s."eTypeParameters";
        t."eSuperTypes" ::= s."eSuperTypes";
        t."eOperations" ::= s."eOperations";
        t."eStructuralFeatures" ::= s."eStructuralFeatures";
        t."eGenericSuperTypes" ::= s."eGenericSuperTypes";

        -- CUSTOM CODE --------------------------------------------------------
        if (t.name = 'Activity') {
          var rNodes := t.eStructuralFeatures.first();
          t.eStructuralFeatures.remove(rNodes);
          createSwimlaneClass().eStructuralFeatures.add(rNodes);
          t.eStructuralFeatures.add(createSwimlaneContainerReference());
        }
        else if (t.name = 'ActivityNode') {
          var rSwimlane   := t.eStructuralFeatures.first();
          rSwimlane.name  := 'swimlane';
          rSwimlane.eType := createSwimlaneClass();
        }
        -----------------------------------------------------------------------
}

rule CopyEDataType
        transform s : Source!"EDataType"
        to t : Target!"EDataType" {
        t."name" := s."name";
        t."instanceClassName" := s."instanceClassName";
        t."instanceTypeName" := s."instanceTypeName";
        t."serializable" := s."serializable";
        t."eAnnotations" ::= s."eAnnotations";
        t."eTypeParameters" ::= s."eTypeParameters";
}

rule CopyEEnum
        transform s : Source!"EEnum"
        to t : Target!"EEnum" {
        t."name" := s."name";
        t."instanceClassName" := s."instanceClassName";
        t."instanceTypeName" := s."instanceTypeName";
        t."serializable" := s."serializable";
        t."eAnnotations" ::= s."eAnnotations";
        t."eTypeParameters" ::= s."eTypeParameters";
        t."eLiterals" ::= s."eLiterals";
}

rule CopyEEnumLiteral
        transform s : Source!"EEnumLiteral"
        to t : Target!"EEnumLiteral" {
        t."name" := s."name";
        t."value" := s."value";
        t."instance" := s."instance";
        t."literal" := s."literal";
        t."eAnnotations" ::= s."eAnnotations";
}

rule CopyEFactory
        transform s : Source!"EFactory"
        to t : Target!"EFactory" {
        t."ePackage" ::= s."ePackage";
        t."eAnnotations" ::= s."eAnnotations";
}

rule CopyEObject
        transform s : Source!"EObject"
        to t : Target!"EObject" {
}

rule CopyEOperation
        transform s : Source!"EOperation"
        to t : Target!"EOperation" {
        t."name" := s."name";
        t."ordered" := s."ordered";
        t."unique" := s."unique";
        t."lowerBound" := s."lowerBound";
        t."upperBound" := s."upperBound";
        t."eType" ::= s."eType";
        t."eGenericType" ::= s."eGenericType";
        t."eAnnotations" ::= s."eAnnotations";
        t."eTypeParameters" ::= s."eTypeParameters";
        t."eParameters" ::= s."eParameters";
        t."eExceptions" ::= s."eExceptions";
        t."eGenericExceptions" ::= s."eGenericExceptions";
}

rule CopyEPackage
        transform s : Source!"EPackage"
        to t : Target!"EPackage" {
        t."name" := 'serviceComposition';
        t."nsURI" := 'www.uca.es/modeling/serviceComposition';
        t."nsPrefix" := 'sc';
        t."eFactoryInstance" ::= s."eFactoryInstance";
        t."eAnnotations" ::= s."eAnnotations";
        t."eClassifiers" ::= s."eClassifiers";
        t."eSubpackages" ::= s."eSubpackages";

        -- CUSTOM CODE --------------------------------------------------------
        t.eClassifiers.add(createSwimlaneClass());
        -----------------------------------------------------------------------
}

rule CopyEParameter
        transform s : Source!"EParameter"
        to t : Target!"EParameter" {
        t."name" := s."name";
        t."ordered" := s."ordered";
        t."unique" := s."unique";
        t."lowerBound" := s."lowerBound";
        t."upperBound" := s."upperBound";
        t."eType" ::= s."eType";
        t.eGenericType ::= s.eGenericType;
        t."eAnnotations" ::= s."eAnnotations";
}

rule CopyEReference
        transform s : Source!"EReference"
        to t : Target!"EReference" {
        t."name" := s."name";
        t."ordered" := s."ordered";
        t."unique" := s."unique";
        t."lowerBound" := s."lowerBound";
        t."upperBound" := s."upperBound";
        t."changeable" := s."changeable";
        t."volatile" := s."volatile";
        t."transient" := s."transient";
        t."defaultValueLiteral" := s."defaultValueLiteral";
        t."unsettable" := s."unsettable";
        t."derived" := s."derived";
        t."containment" := s."containment";
        t."resolveProxies" := s."resolveProxies";
        t."eType" ::= s."eType";
        t."eGenericType" ::= s."eGenericType";
        t."eOpposite" ::= s."eOpposite";
        t."eAnnotations" ::= s."eAnnotations";
        t."eKeys" ::= s."eKeys";
}

rule CopyEStringToStringMapEntry
        transform s : Source!"EStringToStringMapEntry"
        to t : Target!"EStringToStringMapEntry" {
        t."key" := s."key";
        t."value" := s."value";
}

rule CopyEGenericType
        transform s : Source!"EGenericType"
        to t : Target!"EGenericType" {
        t."eUpperBound" ::= s."eUpperBound";
        t."eLowerBound" ::= s."eLowerBound";
        t."eTypeParameter" ::= s."eTypeParameter";
        t."eClassifier" ::= s."eClassifier";
        t."eTypeArguments" ::= s."eTypeArguments";
}

rule CopyETypeParameter
        transform s : Source!"ETypeParameter"
        to t : Target!"ETypeParameter" {
        t."name" := s."name";
        t."eAnnotations" ::= s."eAnnotations";
        t."eBounds" ::= s."eBounds";
}

-- CUSTOM ELEMENT CREATION OPERATIONS ----------------------------------------

@cached
operation createSwimlaneClass() : Target!EClass {
  var cSwimlane := createEClass('Swimlane');
  cSwimlane.addSingleValuedAttribute('name', 'EString');

  -- Add annotations for Eugenia
  var anGmfNode  := createEAnnotation('gmf.node');
  anGmfNode.setMap('figure', 'rectangle');
  anGmfNode.setMap('tool.name', 'Swimlane');
  anGmfNode.setMap('label', 'name');
  cSwimlane.eAnnotations.add(anGmfNode);
  cSwimlane.eStructuralFeatures.add(createSwimlaneOppositeReference());
  return cSwimlane;
}

-*
  An EReference an its opposite present problems for their creation. If
  we used regular, mutually recursive operations, we'd end up in an infinite
  loop. To break the loop, we first create and cache both EReferences, and then
  initialize our part. When the other function is called, it will reuse the
  existing objects and initialize its own half.
*-
@cached
operation createSwimlaneContainerReference() : Target!EReference {
  var rSwimlane := createEmptySwimlaneContainerReference();
  rSwimlane.eOpposite      := createEmptySwimlaneOppositeReference();
  rSwimlane.containment    := true;
  rSwimlane.resolveProxies := true;
  rSwimlane.eType := createSwimlaneClass();
  rSwimlane.name  := 'swimlanes';
  rSwimlane.lowerBound := 1;
  rSwimlane.upperBound := -1;
  var anCompartment    := createEAnnotation('gmf.compartment');
  anCompartment.setMap('layout', 'free');
  rSwimlane.eAnnotations.add(anCompartment);
  return rSwimlane;
}

@cached
operation createSwimlaneOppositeReference() : Target!EReference {
  var rOpSwimlane       := createEmptySwimlaneOppositeReference();
  rOpSwimlane.eOpposite := createEmptySwimlaneContainerReference();
  rOpSwimlane.name := 'activity';
  rOpSwimlane.lowerBound := 1;
  rOpSwimlane.upperBound := 1;
  rOpSwimlane.eType
    := Source!EClass.all.selectOne(r|r.name='Activity').equivalent();
  return rOpSwimlane;
}

@cached
operation createEmptySwimlaneContainerReference() {
  return new Target!EReference;
}

@cached
operation createEmptySwimlaneOppositeReference() {
  return new Target!EReference;
}

-- UTILITY OPERATIONS ---------------------------------------------------------

@cached
operation createEClass(className : String) : Target!EClass {
  var class  := new Target!EClass;
  class.name := className;
  return class;
}

operation createEAnnotation(annotationSource : String) : Target!EAnnotation {
  var annotation    := new Target!EAnnotation;
  annotation.source := annotationSource;
  return annotation;
}

operation Target!EAnnotation setMap(key : String, value : String) {
 var mapEntry := new Target!EStringToStringMapEntry;
 mapEntry.key   := key;
 mapEntry.value := value;
 self.details.add(mapEntry);
}

operation Target!EClassifier addSingleValuedAttribute(attrName : String, attrType : String) {
 var attribute  := new EAttribute;
 attribute.name := attrName;
 attribute.changeable := true;
 attribute.unsettable := false;
 attribute.lowerBound := 1;
 attribute.eType := Target!EDataType.all.selectOne(r|r.name=attrType);
 if (not attribute.eType.isDefined()) {
   attribute.eType := ECore!EDataType.all.selectOne(r|r.name=attrType);
 }

 self.eStructuralFeatures.add(attribute);
}