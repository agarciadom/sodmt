-*
  Algorithm for computing the time limits in seconds for each activity node
  in the ServiceComposition and ServiceProcess models. This is an alternative
  formulation which does not need to list all the paths in the graph.

  Copyright (c) 2010 Antonio García Domínguez.  All rights reserved. This
  program and the accompanying materials are made available under the terms
  of the Eclipse Public License v1.0 which accompanies this distribution, and
  is available at http://www.eclipse.org/legal/epl-v10.html

  Contributors:
     Antonio García Domínguez - initial API and implementation
*-

import '../common/utils.eol';

-*
  Preconditions: the start node is defined and is the only initial node of an
  acyclic and weakly connected graph, for which all constraints in the EVL
  scripts in this plug-in hold.

  Postconditions: updates or creates the performance annotations in each
  activity with the proper values, so the composition QoS is achieved and the
  load is split equally across the system, giving more slack to noncritical
  activities.

  Returns true when all nodes reachable from the starting node are
  successfully annotated, and false otherwise.
*-
$pre start.isDefined()
operation annotateTimeLimitsNew(start : FlowNode) : Boolean {
  var global_limit  := start.getGlobalTimeLimit();
  var rootSupernode := condenseGraph(start, global_limit);
  var manualTimeLimitSum := rootSupernode.at(1);
  var weightSum := rootSupernode.last();

  var slack := global_limit - manualTimeLimitSum;
  if (isApproximatelyEqual(slack, 0, 0.0001) and weightSum > 0.0d) {
      System.user.inform('Nodes with manual restrictions left no slack '
        + 'to establish the automatic restrictions (had '
        + global_limit + ' seconds)');
      return false;
  } else if (slack < 0) {
    System.user.inform('Nodes with manual restrictions'
      + ' have used up more than the available time ('
      + manualTimeLimitSum + ', with ' + global_limit + ' available)');
    return false;
  }

  printTree(rootSupernode, '');
  expandGraph(rootSupernode, start.getGlobalTimeLimit());
  return true;
}

-*
  Condenses a graph into a tree of supernodes.

  Preconditions: the start node is defined and is the only initial node of a
  valid graph.

  Postconditions: returns the root supernode, which condenses the whole graph
  into a single node. Each supernode is a sequence {n,t,w}, where n is a
  sequence with its children (which may be sequences of the same form for
  child supernodes or standalone Activity objects for leaf nodes) and t and w
  are, respectively, the sum of the manual time limits and the sum of the
  weights of the activities of the most restrictive path in the matching
  subgraph of the original graph.

  Side effects: automatic time limit constraints are relaxed on every node that
  is reachable from the starting node.
*-
operation condenseGraph(start : FlowNode, resetValue : Real) : Sequence {
  var children  := Sequence {};
  var weightSum := 0.0d;
  var manualTimeLimitSum := 0.0d;

  var currentNode := start;
  while (not currentNode.isKindOf(FinalNode)) {
    if (currentNode.outgoing.size() > 1) { -- fork/decision
      var branches       := condenseBranches(currentNode, resetValue);
      var maxLimitWeight := getMaxConstraintsFromAllBranches(branches);
      var maxLimit       := maxLimitWeight.first();
      var maxWeight      := maxLimitWeight.last();

      children.add(Sequence { branches, maxLimit, maxWeight });
      return Sequence { children, manualTimeLimitSum + maxLimit, weightSum + maxWeight };
    }
    else if (currentNode.incoming.size() > 1) { -- join/merge
      var thisBranch := Sequence {children, manualTimeLimitSum, weightSum};
      -- Add this branch to the list of visited branches
      if (currentNode.~visitedBranches.isDefined()) {
        currentNode.~visitedBranches.add(thisBranch);
      } else {
        currentNode.~visitedBranches := Sequence { thisBranch };
      }
      -- Have we visited all branches?
      if (currentNode.~visitedBranches.size() == currentNode.incoming.size()) {
        -- Yes: join the branches into a single node and add it to this supernode.
        -- Continue with the next node.
        var maxLimitWeight := getMaxConstraintsFromAllBranches(currentNode.~visitedBranches);
        var maxLimit  := maxLimitWeight.first();
        var maxWeight := maxLimitWeight.last();

        -- Replace current values with those from the supernode
        var mergedSupernode := Sequence { currentNode.~visitedBranches, maxLimit, maxWeight };
        children := Sequence { mergedSupernode };
        manualTimeLimitSum := maxLimit;
        weightSum := maxWeight;
      }
      else {
        -- No: return a special value for condenseBranches
        return Sequence {};
      }
    }
    else if (currentNode.isKindOf(Activity)) {
      children.add(currentNode);
      if (currentNode.hasManualPerformanceAnnotation()) {
        manualTimeLimitSum := manualTimeLimitSum + currentNode.getTimeLimit();
      } else {
        if (currentNode.hasAutomaticPerformanceAnnotation()) {
          currentNode.annotation.secsTimeLimit := resetValue;
        }
        weightSum := weightSum + currentNode.getWeight();
      }
    }

    -- Go to the next node
    currentNode := currentNode.outgoing.first().target;
  }

  return Sequence { children, manualTimeLimitSum, weightSum };
}

-*
  Returns a sequence of supernodes for all branches which start at a
  node. Sets of branches which are later merged are considered as a
  single branch.
*-
operation condenseBranches(start : FlowNode, resetValue : Real) : Sequence {
  var branches := Sequence {};
  for (branchStart in start.outgoing.collect(r|r.target)) {
    var condensedBranch := condenseGraph(branchStart, resetValue);
    -- Condensed branch may be empty if it ends at a merge node which still
    -- has branches left to visit.
    if (not condensedBranch.isEmpty()) { 
      branches.add(condensedBranch);
    }
  }
  return branches;
}

-*
  Returns a {t, w} sequence, where t is the sum of all manual time limits and
  w is the sum of all the weights from the most restrictive branch among all
  branches.
*-
$pre not branches.isEmpty()
$post _result.forAll(r|r>=0.0d)
operation getMaxConstraintsFromAllBranches(branches : Sequence) : Sequence {
  var maxLimit  := 0.0d;
  var maxWeight := 0.0d;
  for (branch in branches) {
    var branchLimit  := branch.at(1);
    var branchWeight := branch.last();
    if (branchLimit > maxLimit) {
      maxLimit  := branchLimit;
      maxWeight := branchWeight;
    }
    else if (isApproximatelyEqual(branchLimit, maxLimit, 0.001)
             and branchWeight > maxWeight) {
      maxWeight := branchWeight;
    }
  }
  return Sequence { maxLimit, maxWeight };
}

-*
  Expands a supernode tree and assigns time limits to the free activities.
  
  Precondition: root is the root supernode of the tree returned by condenseGraph.
  
  Postcondition: each leaf node in the tree is annotated with a time limit
  so all paths meet the composition's QoS, the load is distributed equally
  across the composition and the noncritical activities receive as much slack
  as possible.

  Returns true if successful, and false if not. The algorithm will fail if the
  user has specified inconsistent manual time limits. 
*-
$pre root.isDefined() and root.size() == 3 and global_limit >= 0.0d
operation expandGraph(root : Sequence, global_limit : Real) : Boolean {

  // Split supernode into components
  var children           := root.first();
  var manualTimeLimitSum := root.at(1);
  var weightSum          := root.last();

  // Distribute equally the slack among the children
  var slack := global_limit - manualTimeLimitSum;
  System.user.println('Distributing (' + global_limit + ' - ' + manualTimeLimitSum + ') = ' + slack + ' among ' + weightSum + ' activities');
  for (child in children) {
    if (child.isKindOf(Sequence)) {
      -- Every child supernode will need enough time for its own manual time
      -- limits, and will receive in addition its part of the slack.
      var childTimeLimitSum := child.at(1);
      var childWeightSum    := child.last();

      if (weightSum > 0.0d) {
        var childRatioSlack   := childWeightSum/weightSum;
        var childSlack        := slack * childRatioSlack;
        expandGraph(child, childTimeLimitSum + childSlack);
      } else {
        expandGraph(child, childTimeLimitSum);
      }
    }
    else if (not child.hasManualPerformanceAnnotation()) {
      -- Free activity: set its time limit
      var ratio := child.getWeight()/weightSum;
      child.setTimeLimit(slack * ratio);
    }
  }
}

-- UTILITY/DEBUGGING

operation printTree(root : Sequence, indent : String) {
  if (root.size() == 3) {
    System.user.println(indent + 'Supernode: ');
  } else {
    System.user.println(indent + 'Children: ');
  }
  for (child in root) {
    printTree(child, indent + '  ');
  }
}

operation printTree(act : Activity, indent : String) {
  System.user.println(indent + 'Activity : ' + act.name);
}

operation printTree(elem, indent : String) {
  System.user.println(indent + 'Other : ' + elem);
}
