-*
  Accessors and mutators for MDT UML2 models annotated with the MARTE profile.

  Copyright (c) 2011 Antonio García Domínguez.  All rights
  reserved. This program and the accompanying materials are made
  available under the terms of the Eclipse Public License v1.0 which
  accompanies this distribution, and is available at
  http://www.eclipse.org/legal/epl-v10.html

  Contributors:
     Antonio García Domínguez - initial API and implementation
*-

-*
  OPERATIONS FOR Activity
*-
@cached
operation Activity getTimeLimit() : Real {
  return self.getScenario().respT.first().keyvalMap().get("value").asReal() * 1.0d;
}

@cached
$pre self.getScenario().isDefined()
operation Activity getThroughput() : Real {
  return self.getScenario().throughput.first().keyvalMap().get("value").asReal() * 1.0d;
}

@cached
operation Activity getAnalysisContext() : GaAnalysisContext {
  var context := GaAnalysisContext.allInstances.select(e|e.base_NamedElement == self).first();
  if (context.isDefined()) {
    return context;
  }
  else {
    var context := new GaAnalysisContext;
    context.base_NamedElement := self;
    return context;
  }
}

-- Sets the value of a slack per unit of weight variable.
operation Activity setSWVariable(name : String, value : Real) {
  var ctx      := self.getAnalysisContext().context;
  var fullExpr := "$" + name + " : Real = " + value;

  -- Search if the variable is already declared in the context.
  var iParam := 0;
  while (iParam < ctx.size()) {
    var parameter := ctx.at(iParam);
    var paramName := parameter.split(" *[$:] *").at(1);
    if (name == paramName) {
      -- The variable is already declared: replace its value and we're done.
      ctx.removeAt(iParam);
      ctx.add(iParam, fullExpr);
      return;
    }

    iParam := iParam + 1;
  }

  -- The variable was not part of the context yet: add it.
  ctx.add(fullExpr);
}

-*
  OPERATIONS FOR ExecutableNode
*-
$pre self.getStep().isDefined()
operation ExecutableNode setThroughput(newThroughput : Real) {
  var step := self.getStep();
  step.throughput.clear();
  step.throughput.add('(value=' + newThroughput + ',source=calc)');
}

$pre self.getStep().isDefined()
operation ExecutableNode getTimeLimit() : Real {
  var stepHD := self.getStep().hostDemand;
  var kvCalcHD := stepHD.collect(e|e.keyvalMap()).select(kv|kv.get("source") == "calc").first();
  if (kvCalcHD.isDefined()) {
    return kvCalcHD.get("value").asReal() * 1.0d;
  }
  else {
    return 0.0d;
  }
}

$pre self.getStep().isDefined()
operation ExecutableNode setTimeLimit(newTimeMillis : Real) {
  var step := self.getStep();

  -- Remove all constraints not set by the user
  step.hostDemand := step.hostDemand.select(e|e.keyvalMap().get("source") == "req");

  -- Add a calculated constraint with the time
  step.hostDemand.add('(value=' + newTimeMillis + ',source=calc)');
}

$pre self.getStep().isDefined()
operation ExecutableNode getThroughput() : Real {
  var throughput := self.getStep().throughput.first();
  if (throughput.isDefined()) {
    return throughput.keyvalMap().get("value").asReal();
  } else {
    return null;
  }
}

@cached
operation ExecutableNode getWeight() : Real {
  return self.getRequiredHostDemand().get("expr").getWeight();
}

@cached
operation ExecutableNode getMinimumTime() : Real {
  return self.getRequiredHostDemand().get("expr").getMinTime();
}

@cached
operation ExecutableNode getVariable() : String {
  return self.getRequiredHostDemand().get("expr").getVariable();
}

@cached
operation ExecutableNode getRepetitions() : Real {
  return self.getStep().rep.asReal();
}

@cached
operation ExecutableNode getRequiredHostDemand() : Map {
  if (self.getStep().isDefined()) {
    return self.getStep().hostDemand.collect(e | e.keyvalMap()).select(kv|kv.get("source") == "req").first();
  } else {
    return '(expr=0.0+1.0*x,source=req)'.keyvalMap();
  }
}

-*
  OPERATIONS FOR ActivityEdge
*-
@cached
$post _result.isDefined() and _result >= 0 and _result <= 1
operation ActivityEdge getProbability() : Real {
  var step := self.getStep();

  if (step.isDefined()) {
    return step.prob.asReal();
  } else {
    return 1.0d;
  }
}

-*
  OPERATIONS FOR NamedElement
*-
operation NamedElement setThroughput(newThroughput : Real) {
  -- do nothing
}

operation NamedElement setTimeLimit(newTimeMillis : Real) {
  -- do nothing
}

operation NamedElement getThroughput() : Real {
  return 0.0d;
}

operation NamedElement getWeight() : Real {
  return 0.0d;
}

operation NamedElement getMinimumTime() : Real {
  return 0.0d;
}

operation NamedElement getVariable() : String {
  return null;
}

operation NamedElement getRepetitions() : Real {
  return 0.0d;
}

@cached
operation NamedElement getRequiredHostDemand() : Map {
  return '(expr=0+0*x,source=req)'.keyvalMap();
}

@cached
operation NamedElement getScenario() : GaScenario {
  return GaScenario.allInstances.select(s|s.base_NamedElement == self).first();
}

@cached
operation NamedElement getStep() : GaStep {
  return GaStep.allInstances.select(s|s.base_NamedElement == self).first();
}

@cached
operation NamedElement getAnalysisContext() : GaAnalysisContext {
  return GaAnalysisContext.allInstances.select(s|s.base_NamedElement == self).first();
}

-*
  STRING OPERATIONS
*-

-*
  Extracts the minimum time m in a time constraint of the form m + w * swI,
  ignoring whitespace.
*-
operation String getMinTime() : Real {
  return self.split(" *[+*] *").at(0).asReal() * 1.0d;
}

-*
  Extracts the weight w in a time constraint of the form m + w * swI,
  ignoring whitespace.
*-
operation String getWeight() : Real {
  return self.split(" *[+*] *").at(1).asReal() * 1.0d;
}

-*
  Extracts the variable swI in a time constraint of the form m + w * swI,
  ignoring whitespace.
*-
operation String getVariable() : String {
  return self.split(" *[+*] *").last();
}

-*
  Computes the key-value map from a tuple of the form '(a = b, c = d, ...)',
  ignoring initial and trailing whitespace in keys and values.
*-
operation String keyvalMap() : Map {
  var input := self;
  if (input.startsWith('(')) {
    input := input.substring(1, input.length() - 1);
  }
  var pairs := input.split(" *, *");
  var result : Map;
  for (pair in pairs) {
    var parts := pair.split(" *= *");
    result.put(parts.first(), parts.second());
  }
  return result;
}