import '../common/utils.eol';

context FlowNode {

  -- We use two constraints for the incoming count (min, max) so we only
  -- propose the join fix in the right situations. This would be much easier if
  -- fixes had guards like in the Epsilon book, but it works.
  constraint MinimumOneIncoming {
    guard : not self.isKindOf(InitialNode)
    check : self.incoming.size() >= 1
    message : 'All activity nodes except initial nodes must have at least one incoming edge'
  }

  constraint MaximumOneIncoming {
    guard : not self.isKindOf(JoinNode)
            and InitialNode.all.forAll(r|r.satisfies('NoCyclesCompleteGraph'))
            and self.satisfies('SameFlowTypeForAllIncoming')
    check : self.incoming.size() <= 1
    message : 'All activity nodes except joins must have at most one incoming edge'
    fix {
      title : 'Add join node in the middle'
      do {
        var newJoin := self.newJoinNode();
        self.placeNodeBetween(newJoin, NodeSide#INCOMING);
      }
    }
  }

  -- See above comment for an explanation of why we use both min and max
  -- constraints instead of just one
  constraint MinimumOneOutgoing {
    guard : not self.isKindOf(FinalNode)
    check : self.outgoing.size() >= 1
    message : 'All activity nodes except final nodes must have at least one outgoing edge'
  }

  constraint MaximumOneOutgoing {
    guard : not self.isKindOf(ForkNode)
            and not self.isKindOf(DecisionNode)
            and InitialNode.all.forAll(r|r.satisfies('NoCyclesCompleteGraph'))
            and self.satisfies('SameFlowTypeForAllOutgoing')
    check : self.outgoing.size() <= 1
    message : 'All activity nodes except forks and decisions must have at most one outgoing edge'
    fix {
      title : 'Add fork node in the middle'
      do {
        var newFork := self.newForkNode();
        self.placeNodeBetween(newFork, NodeSide#OUTGOING);
      }
    }
    fix {
      title : 'Add decision node in the middle'
      do {
        var newDecision := self.newDecisionNode();
        self.placeNodeBetween(newDecision, NodeSide#OUTGOING);
      }
    }
  }
  
  constraint SameFlowTypeForAllIncoming {
    guard : self.satisfies('MinimumOneIncoming')
    check : self.incoming.forAll(r|r.type() == self.incoming.first().type())
    message : 'All incoming links should be of the same type'
  }
  
  constraint SameFlowTypeForAllOutgoing {
    guard : self.satisfies('MinimumOneOutgoing')
    check : self.outgoing.forAll(r|r.type() == self.outgoing.first().type())
    message : 'All outgoing links should be of the same type'
  }
  
  constraint SameFlowTypeForAllIncomingAndOutgoing {
    guard : self.satisfies('SameFlowTypeForAllIncoming')
            and self.satisfies('SameFlowTypeForAllOutgoing')
            and not self.isKindOf(Activity)
    check : self.incoming.forAll(r|r.type() == self.outgoing.first().type())
    message : 'All incoming and outgoing links should be of the same type, except for executable nodes'
  }
}

-- Flow constraints -------------------------------

context FlowEdge {
  constraint BothEndsDefined {
    check : self.source.isDefined() and self.target.isDefined()
    message : 'Source and target of an edge must be defined'
  }

  constraint NoCycles {
    check : self.source <> self.target
    message : 'Source and target of an edge must not be the same'
    fix {
      title : 'Remove link from model'
      do {
        delete self;
      }
    }
  }
}

context ControlFlow {
  constraint ConditionsOnlyFromDecisionNode {
    check : self.condition <> '' implies self.source.isKindOf(DecisionNode)
    message : 'Conditions can only be applied to edges starting from a decision node'
    fix {
      title : 'Remove condition'
      do {
        self.condition := '';
      }
    }
  }

  constraint ConditionsAlwaysFromDecisionNode {
    check : self.source.isKindOf(DecisionNode) implies self.condition <> ''
    message : 'Conditions must be applied to edges starting from a decision node'
    fix {
      title : 'Add dummy condition'
      do {
        self.condition := 'dummy';
      }
    }
  }

  constraint ValidProbabilityWithCondition {
    guard : self.satisfies('ConditionsOnlyFromDecisionNode')
            and self.satisfies('ConditionsAlwaysFromDecisionNode')
            and self.condition <> ''
    check : self.probability > 0 and self.probability < 1
    message : 'Condition must be true with probability > 0 and < 1'
  }

  constraint ValidProbabilityWithoutCondition {
    guard : self.satisfies('ConditionsOnlyFromDecisionNode')
            and self.satisfies('ConditionsAlwaysFromDecisionNode')
            and self.condition = ''
    check : (self.probability - 1).abs() <= 0.001
    message : 'Unconditional control flows should have probability equal to 1'
    fix {
      title : 'Set probability to 1'
      do {
        self.probability = 1.0d;
      }
    }
  }

  constraint SourceMustNotBeObjectNode {
    guard : self.source.isDefined()
    check : not self.source.isKindOf(ObjectNode)
    message : 'The source of a control flow cannot be an object node'
  }

  constraint TargetMustNotBeObjectNode {
    guard : self.target.isDefined()
    check : not self.target.isKindOf(ObjectNode)
    message : 'The target of a control flow cannot be an object node'
  }
}

context ObjectFlow {
  constraint EitherSourceOrTargetMustBeObjectNode {
    guard : self.source.isDefined() and self.target.isDefined()
    check : self.source.isKindOf(ObjectNode) xor self.target.isKindOf(ObjectNode)
    message : 'Either the source or the target of an object flow must be an object node, but not both'
  }

  constraint EitherSourceOrTargetMustBeActivity {
    guard : self.source.isDefined() and self.target.isDefined()
    check : self.source.isKindOf(Activity) xor self.target.isKindOf(Activity)
    message : 'Either the source or the target of an object flow must be an executable node, but not both'
  }
}

-- Annotation constraints -------------------------

context PerformanceAnnotation {
  constraint ValidConcurrentUsers {
    check : self.concurrentUsers > 0
    message : 'Transactions per sec must be a natural number'
  }
  constraint ValidTimeLimit {
    check : self.secsTimeLimit > 0
    message : 'The time limit for a single transaction must be '
              + 'greater than 0'
  }
}

context ActivityPerformanceAnnotation {
  constraint IsLinkedToNode {
    check : self.execNode.isDefined()
    message : 'The annotation must be linked to an executable node'
  }
  constraint LinkedNodeIsActivity {
    guard : self.satisfies('IsLinkedToNode')
    check : self.execNode.isKindOf(Activity)
    message : 'The linked activity node must be an executable node'
  }
}

-- Node constraints -----------------------------

context InitialNode {

  constraint AllPathsFromInitialNodeMustEndInFinalNode {
    guard : self.satisfies('NoCyclesCompleteGraph')
    check : getAllPathsFrom(self).forAll(r|r.last().isKindOf(FinalNode))
    message : 'All paths from an initial node must end in a final node'
  }

  constraint NoIncomingForInitialNode {
    check : self.incoming.isEmpty()
    message : 'The initial node must not have any incoming edges'
    fix {
      title : 'Remove incoming edges from initial node'
      do {
        for (e in self.incoming.clone()) {
          delete e;
        }
      }
    }
  }

  constraint AtLeastOneActivityNodeBetweenInitialAndFinalNodes {
    guard : self.satisfies('MaximumOneOutgoing')
    check : self.outgoing.forAll(e| not e.target.isKindOf(FinalNode))
    message : 'There must be at least one activity node between the initial '
              + 'node and the final node'
    fix {
      title : 'Add dummy executable node'
      do {
        var newExec = self.newActivity();
        newExec.name := 'Do something';
        self.placeNodeBetween(newExec, NodeSide#OUTGOING);
      }
    }
  }

  -- TODO: add support for loops to the propagation algorithm,
  -- using some probability threshold configurable by the user.
  -- The NoCycles constraint in the FlowEdge context is still
  -- useful, as it is easier to understand for the user. This
  -- constraint might be removed in the future.
  constraint NoCyclesCompleteGraph {
    check : graphIsAcyclic(self)
    message : 'Starting from the initial node, the graph cannot contain any cycles'
    fix {
      title : 'Remove one of the edges of the cycle'
      do {
        delete self.~firstEdgeProducingCycle;
      }
    }
  }
}

context FinalNode {
  constraint NoOutgoingForFinalNode {
    check : self.outgoing.isEmpty()
    message : 'The final node must not have any outgoing edges'
    fix {
      title : 'Remove outgoing edges from final node'
      do {
        for (e in self.outgoing.clone()) {
          delete e;
        }
      }
    }
  }
}

context NamedElement {
  constraint NameMustNotBeEmpty {
    check : self.name <> ''
    message : 'The name of a named element must not be empty'
  }
}

context ForkNode {
  constraint MoreThanOneOutgoingFlowWithFix {
    guard : self.satisfies('MinimumOneIncoming')
            and self.satisfies('MinimumOneOutgoing') 
    check : self.outgoing.size() > 1
    message : 'A fork node must have more than one outgoing edge'
    fix {
      title : 'Convert fork node and edges into a single edge'      
      do {
        self.incoming.first.target := self.outgoing.first.target;
        delete self.outgoing.first;
        delete self;
      }
    }
  }
}

context JoinNode {
  constraint MoreThanOneIncomingFlow {
    guard : self.satisfies('MinimumOneIncoming')
            and self.satisfies('MinimumOneOutgoing')   
    check : self.incoming.size() > 1
    message : 'A join node must have more than one incoming edge'
    fix {
      title : 'Convert join node and edges into a single edge'
      do {
        self.incoming.first.target := self.outgoing.first.target;
        delete self.outgoing.first;
        delete self;
      }
    }
  }
  constraint JoinedBranchesMustPairwiseHaveSameLCA {
    guard : self.satisfies('MoreThanOneIncomingFlow')
            and InitialNode.all.forAll(r|r.satisfies('NoCyclesCompleteGraph'))
    check {
      var parents := self.incoming.collect(r|r.source);
      var nElems  := parents.size();
      var iFirst  := 0;
      var lca;
      while (iFirst < nElems) {
        var first   := parents.at(iFirst);
        var iSecond := iFirst + 1;
        while (iSecond < nElems) {
          var second := parents.at(iSecond);
          var currentLca := getLCA(first, second);
          if (lca.isDefined() and lca <> currentLca) {
            return false;
          }
          lca     := currentLca;
          iSecond := iSecond + 1;
        }
        iFirst := iFirst + 1;
      }
      return true;
    }
    message : 'A join node must only join branches which split off from the exact same node'
  }
}

context DecisionNode {
  constraint TotalProbabilityIsOne {
    guard : self.outgoing.forAll(r|r.satisfies('ValidProbabilityWithCondition'))
    check {
      var totalProb := 0;
      for (out in self.outgoing) {
        totalProb := totalProb + out.probability;
      }
      var delta := (1 - totalProb).abs();
      return delta <= 0.001;
    }
    message : 'The sum of the probabilities of all the decision outcomes must be equal to 1'
  }
}

-- Operations -----------------------------------

-- Edge creation

$"pre" e.isDefined()
operation createEdgeSimilarTo(e : FlowEdge) {
  var utilsTool := new Native('es.uca.modeling.eol.tools.ECoreUtilsTool');
  var newEdge := utilsTool.copy(e);
  addEdge(newEdge);
  return newEdge;
}

-- Adds another node between a node and its direct ancestors or descendants
-- FIXME: Cannot use "NodeSide" as the parameter type (Eclipse Bugzilla #286412)
$"pre"  newNode.isDefined() and side.isDefined()
$"pre"  (side = NodeSide#OUTGOING and self.outgoing.size() >= 1) or (side = NodeSide#INCOMING and self.incoming.size() >= 1)
$"post" (side = NodeSide#OUTGOING and self.outgoing.size() = 1) or (side = NodeSide#INCOMING and self.incoming.size() = 1)
operation FlowNode placeNodeBetween(newNode : FlowNode, side : Any) {
  if (side = NodeSide#OUTGOING) {
    var newEdge := createEdgeSimilarTo(self.outgoing.first());
    for (e in self.outgoing.clone()) {
       e.source := newNode;
    }
    newEdge.source := self;
    newEdge.target := newNode;
  } else {
    var newEdge := createEdgeSimilarTo(self.incoming.first());
    for (e in self.incoming.clone()) {
      e.target := newNode;
    }
    newEdge.source := newNode;
    newEdge.target := self;
  }
}

-- Cycle testing

operation graphIsAcyclic(start : FlowNode) {
  -- Mark all vertices as not visited
  for (v in FlowNode.all) {
    v.~visitStatus := VisitStatus#NOT_VISITED;
  }
  start.~firstEdgeProducingCycle := getFirstEdgeProducingCycle(start);
  return start.~firstEdgeProducingCycle.isUndefined();
}

$"pre" node.~visitStatus <> VisitStatus#VISITING
operation getFirstEdgeProducingCycle(node : FlowNode) {
  -- All ancestors already visited: nothing to do
  if (node.~visitStatus = VisitStatus#VISITED) {
    return;
  }

  node.~visitStatus := VisitStatus#VISITING;
  for (edge in node.outgoing) {
    if (edge.target.~visitStatus = VisitStatus#VISITING) {
      return edge;
    }

    var firstEdgeProducingCycle := getFirstEdgeProducingCycle(edge.target);
    if (firstEdgeProducingCycle.isDefined()) {
      return firstEdgeProducingCycle;
    }
  }
  node.~visitStatus := VisitStatus#VISITED;
}
