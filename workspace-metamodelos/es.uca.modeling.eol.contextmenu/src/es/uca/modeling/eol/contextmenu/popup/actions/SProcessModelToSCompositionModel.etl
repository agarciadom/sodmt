rule CopyServiceProcess
  transform s : Source!ServiceProcess
  to t : Target!ServiceComposition {

  var equivalents := s.nodes.equivalents().flatten();
  var equivNodes  := equivalents.select(r|r.isKindOf(Target!CompositionFlowNode));
  var equivAEdges := equivalents.select(r|r.isKindOf(Target!ActivityFlowEdge));

  t.nodes            := equivNodes;
  t.compositionEdges ::= s.edges;
  t.activityEdges    := equivAEdges;
  t.swimlanes := new Target!SwimlaneContainer;
  t.swimlanes.swimlaneNames.add('Main');
  t.activityPerformance ::= s.activityPerformance;
}

rule CopyActivityPerformanceAnnotation
  transform s : Source!ActivityPerformanceAnnotation
  to t : Target!ActivityPerformanceAnnotation {
  t.transactionsPerSec := s.transactionsPerSec;
  t.secsTimeLimit := s.secsTimeLimit;
  t.execNode ::= s.execNode;
}

rule CopyProcessControlFlow
  transform s : Source!ProcessControlFlow
  to t : Target!CompositionControlFlow {
  t.condition := s.condition;
  t.probability := s.probability;
  t.target ::= s.target;
  t.source ::= s.source;
}

rule CopyServiceActivity
  transform s : Source!ServiceActivity
  to t  : Target!ServiceActivity,
     e1 : Target!ActivityControlFlow,
     e2 : Target!ActivityControlFlow {
   t.name := s.name;
   t.annotation ::= s.annotation;
   t.incoming ::= s.incoming;
   t.outgoing ::= s.outgoing;

   var acStart   := new Target!ActivityStart;
   var acFinish  := new Target!ActivityFinish;
   var acAction  := new Target!ActivityAction;
   acAction.name := s.name;

   t.nodes.add(acStart);
   t.nodes.add(acFinish);
   t.nodes.add(acAction);

    e1.source := acStart;
    e1.target := acAction;
    e2.source := acAction;
    e2.target := acFinish;
}

rule CopyProcessStart
  transform s : Source!ProcessStart
  to t : Target!CompositionStart {
  t.incoming ::= s.incoming;
  t.outgoing ::= s.outgoing;
}

rule CopyProcessFinish
  transform s : Source!ProcessFinish
  to t : Target!CompositionFinish {
  t.incoming ::= s.incoming;
  t.outgoing ::= s.outgoing;
}

rule CopyProcessDecision
  transform s : Source!ProcessDecision
  to t : Target!CompositionDecision {
  t.incoming ::= s.incoming;
  t.outgoing ::= s.outgoing;
}

rule CopyProcessFork
  transform s : Source!ProcessFork
  to t : Target!CompositionFork {
  t.incoming ::= s.incoming;
  t.outgoing ::= s.outgoing;
}

rule CopyProcessJoin
  transform s : Source!ProcessJoin
  to t : Target!CompositionJoin {
  t.incoming ::= s.incoming;
  t.outgoing ::= s.outgoing;
}
