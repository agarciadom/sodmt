-*
  Heuristic algorithm for computing the transactions per sec required
  for each activity node in the ServiceComposition and ServiceProcess
  models.

  Copyright (c) 2009 Antonio García Domínguez.  All rights
  reserved. This program and the accompanying materials are made
  available under the terms of the Common Public License v1.0 which
  accompanies this distribution, and is available at
  http://www.eclipse.org/legal/cpl-v10.html

  Contributors:
     Antonio García Domínguez - initial API and implementation

  The algorithm computes the transactions per second of every node and
  edge, but only adds annotation model elements to the executabl
  nodes. IMPORTANT: the model must have been validated with the EVL
  script in es.uca.modeling.validation and pass with no errors.

  The algorithm follows these steps:

  - Reset all automatically inferred performance annotations by
    relaxing them to 0 transactions per minute. We can't just delete
    them, as that'd remove them from any diagrams they were in, and
    the user would have to place them again in the right part of the
    diagram.

  - Starting from the initial node, we perform a breadth-first
    traversal of the graph, making sure that each node is only visited
    once all its ancestors have been visited (i.e. annotated with the
    computed transactions per second). The computed value depends on
    the kind of node visited. If T(x) is the transactions per sec for
    any node and P(e) the traversal probability annotated on an edge,
    then the formulas are as follows:

    * T(initial node) = T(its ServiceActivity)
    * T(edge) = P(edge) * T(source)
    * T(node, except JoinNode) = T(only incoming edge)
    * T(JoinNode): described more in detail below.

    We compute these values even for nodes which have manual
    annotations. It might happen that the user has set a lower value
    in the node than that required for the whole service activity to
    have the required performance. In these cases, the user will be
    prompted if they want the node to be updated. If the node cannot
    be updated, the execution of the algorithm will be aborted.

  JoinNodes have to be handled in a different way. Their transactions
  per sec depend on how each pair of the paths joined split off
  originally.

  For instance, if they split at a DecisionNode, we'll have to sum
  their transactions per sec limits. However, if they split at a
  ForkNode, we'll just use the minimum value (we previously used the
  maximum value, but as Paco said, it didn't make sense). We do not
  check all pairs, however: we simply perform this calculation with
  the first and second path, then with its result and that of the
  third path, and so on. The idea is that if we're handling this
  graph:

    A --> Decision --> Fork --> B --> Join --> C
                    |        \> D -/
                    \---------> E -/

  as this one, which is restricted to binary joins but otherwise works
  the same:

    A --> Decision --> Fork --> B --> Join --> Join --> C
                    |        \> D -/        |
                    \---------> E ----------/

  Knowing where B and D or B and E split off is a well-known problem
  in graph theory known as the Lowest Common Ancestor (LCA). There are
  many algorithms for this. We're using the simplest algorithm, and
  also the least efficient when used repeatedly: we obtain all the
  ancestors of both nodes, intersect the resulting sets, sort them by
  depth in descending order and take the first element. It is good
  enough for now: we only need to do this at join nodes, and graphs
  don't tend to get large enough.

  Finally, by using Epsilon EMC's facilities, the whole annotation
  process is performed with transactional semantics. If it is aborted
  in the middle, all changes will be rolled back. Undo and redo also
  work as usual.

*-

import '../common/utils.eol';

-*
  This wizard operation can ask the user if they want to update existing
  constraints to make them stricter if they're set too lax. However, this means
  that we need to walk the graph so these updates reach all the affected nodes.
  We will go through all ExecutableNodes, sorting them by depth in ascending
  order.
*-
operation annotateTransactionsPerSec(start : FlowNode) {
  transaction {
    var allNodes := start.getAllReachableNodes().select(r|r.isKindOf(ExecutableNode));

    -- Relax all automatic constraints before continuing
    for (node in allNodes.select(r|r.hasAutomaticPerformanceAnnotation())) {
      node.annotation.transactionsPerSec := 0.0d;
    }
    for (node in allNodes.sortBy(r|r.getDepth())) {
	  var auto := node.getAutoTransactionsPerSec();
      if (node.hasManualPerformanceAnnotation()) {
        if (node.getTransactionsPerSec() < auto
            and not System.user.confirm('The manual restriction of '
              + node.getTransactionsPerSec()
              + ' transactions per second in ' + node
              + ' is set too low. Update to ' + auto
              + '? Otherwise, the wizard will be aborted.')) {
           abort; return;
        }
        else if (node.getTransactionsPerSec() >= auto) {
          continue;
        }
      }
      node.setTransactionsPerSec(auto);
    }
  }
}

-- AUTOMATIC TRANSACTIONS PER SEC RESTRICTION COMPUTATION ---------------------

-*
  All nodes and edges have a minimum number of transactions per sec
  that they can handle. However, only the executable nodes can have performance
  restrictions manually assigned to them. That's why though all edges and nodes
  have the getTransactionsPerSec method, but only ExecutableNodes have the
  getAutoTransactionsPerSec method.

  This way, the wizard can compare the user's manual restrictions with the
  automatically computed values and make them stricter if needed.
*-

@cached
$pre self.source.isDefined() and self.target.isDefined()
operation FlowEdge getTransactionsPerSec() : Real {
  return self.source.getTransactionsPerSec();
}

@cached
$pre self.source.isDefined() and self.target.isDefined()
operation ControlFlow getTransactionsPerSec() : Real {
  return self.probability * self.source.getTransactionsPerSec();
}


@cached
$pre self.incoming.size() = 1
operation FlowNode getTransactionsPerSec() : Real {
  return self.incoming.first().getTransactionsPerSec();
}

@cached
$pre self.incoming.notEmpty()
operation JoinNode getTransactionsPerSec() : Real {
  var firstParent;
  var result;

  for (incomingEdge in self.incoming) {
    var parent := incomingEdge.source;

    if (firstParent.isUndefined()) {
      firstParent := parent;
      result      := incomingEdge.getTransactionsPerSec();
      continue;
    }

    var lca := getLCA(firstParent, parent);
    if (lca.isKindOf(DecisionNode)) {
      result := result + incomingEdge.getTransactionsPerSec();
    }
    else if (lca.isKindOf(ForkNode)) {
      if (incomingEdge.getTransactionsPerSec() < result) {
        result := incomingEdge.getTransactionsPerSec();
      }
    } else {
      System.user.inform('BUG: LCA ' + lca + ' of ' + firstParent
        + ' and ' + parent + ' is neither a DecisionNode nor a ForkNode');
    }
  }

  return result;
}

operation ExecutableNode getTransactionsPerSec() : Real {
  if (self.hasManualPerformanceAnnotation()) {
    return self.annotation.transactionsPerSec;
  } else {
    return self.getAutoTransactionsPerSec();
  }
}

@cached
$pre self.incoming.size() = 1
operation ExecutableNode getAutoTransactionsPerSec() : Real {
  return self.incoming.first().getTransactionsPerSec();
}

$pre newValue >= 0
$pre self.annotation.isUndefined() or self.annotation.transactionsPerSec <= newValue
operation ExecutableNode setTransactionsPerSec(newValue : Real) {
  if (self.annotation.isUndefined()) {
    self.createPerformanceAnnotation();
  }
  self.annotation.transactionsPerSec := newValue;
}