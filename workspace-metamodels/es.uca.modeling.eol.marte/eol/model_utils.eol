-*
  Accessors and mutators for MDT UML2 models annotated with the MARTE profile.

  Copyright (c) 2011-2012 Antonio García Domínguez.  All rights
  reserved. This program and the accompanying materials are made
  available under the terms of the Eclipse Public License v1.0 which
  accompanies this distribution, and is available at
  http://www.eclipse.org/legal/epl-v10.html

  Contributors:
     Antonio García Domínguez - initial API and implementation
*-
import 'utils.eol';

-*
  OPERATIONS FOR Activity
*-
@cached
operation Activity getVSLTool() {
  return new Native("es.uca.modeling.eol.marte.tools.VSLTupleTool");
}

$pre self.getScenario().isDefined() and not self.getScenario().respT.isEmpty()
operation Activity getTimeLimit() : Real {
  var tool := self.getVSLTool();
  return tool.getKeyvalMap(self.getScenario().respT.first()).get("value").asReal() * 1.0d;
}

operation Activity getTimeLimitWithDefault(def : Real) : Real {
  if (self.getScenario().isUndefined() or self.getScenario().respT.isEmpty()) {
    return def;
  }
  return self.getTimeLimit();
}

operation Activity setTimeLimit(newTimeLimit : Real) {
  var scenario := self.getScenario(true);
  scenario.respT.clear();
  scenario.respT.add('(value=' + newTimeLimit + ',unit=s,source=req)');
}

$pre self.getScenario().isDefined() and not self.getScenario().throughput.isEmpty()
operation Activity getThroughput() : Real {
  var tool := self.getVSLTool();
  return tool.getKeyvalMap(self.getScenario().throughput.first()).get("value").asReal() * 1.0d;
}

operation Activity getThroughputWithDefault(def : Real) : Real {
  if (self.getScenario().isUndefined() or self.getScenario().throughput.isEmpty()) {
    return def;
  }
  return self.getThroughput();
}

$pre self.getScenario().isDefined()
operation Activity setThroughput(newThroughput : Real) {
  var scenario := self.getScenario(true);
  scenario.throughput.clear();
  scenario.throughput.add('(value=' + newThroughput + ',unit=Hz,source=req)');
}

@cached
operation Activity getAnalysisContext() : GaAnalysisContext {
  var context := GaAnalysisContext.allInstances.select(e|e.base_NamedElement == self).first();
  if (context.isDefined()) {
    return context;
  }
  else {
    var context := new GaAnalysisContext;
    context.base_NamedElement := self;
    return context;
  }
}

-- Sets the value of a slack per unit of weight variable.
operation Activity setSWVariable(name : String, value : Real) {
  var tool     := self.getVSLTool();
  var ctx      := self.getAnalysisContext().context;
  var fullExpr := "$" + name + " : Real = " + value;

  -- Search if the variable is already declared in the context.
  var iParam := 0;
  while (iParam < ctx.size()) {
    var paramName := tool.getParameterName(ctx.at(iParam));
    if (name == paramName) {
      -- The variable is already declared: replace its value and we're done.
      ctx.removeAt(iParam);
      ctx.add(iParam, fullExpr);
      return;
    }

    iParam := iParam + 1;
  }

  -- The variable was not part of the context yet: add it.
  ctx.add(fullExpr);
}

@cached
operation Activity getStepMap() : Map {
  var map : Map;
  for (step in GaStep.allInstances) {
    map.put(step.base_NamedElement, step);
  }
  return map;
}

-*
  OPERATIONS FOR ExecutableNode
*-
operation ExecutableNode setThroughput(newThroughput : Real) {
  var step := self.getStep(true);
  step.throughput.clear();
  step.throughput.add('(value=' + newThroughput + ',unit=Hz,source=calc)');
}

$pre self.getStep().isDefined()
operation ExecutableNode getTimeLimit() : Real {
  var tool   := self.getActivity().getVSLTool();
  var stepHD := self.getStep().hostDemand;
  var kvCalcHD := stepHD.collect(e|tool.getKeyvalMap(e)).select(kv|kv.get("source") == "calc").first();
  if (kvCalcHD.isDefined()) {
    return kvCalcHD.get("value").asReal() * 1.0d;
  }
  else {
    return 0.0d;
  }
}

operation ExecutableNode setTimeLimit(newTimeMillis : Real) {
  var tool := self.getActivity().getVSLTool();
  var step := self.getStep(true);

  -- Remove all constraints not set by the user
  step.hostDemand := step.hostDemand.select(e | tool.getKeyvalMap(e).get("source") == "req");

  -- Add a calculated constraint with the time
  step.hostDemand.add('(value=' + newTimeMillis + ',unit=s,source=calc)');
}

operation ExecutableNode setRequiredTimeLimit(minTime : Real, weight : Real) {
  var step := self.getStep(true);
  step.hostDemand.clear();

  var expr := minTime + ' + ' + weight + ' * ' + self.getContextParameterName();
  var entry := '(expr=' + expr + ',unit=s,source = req)';
  step.hostDemand.add(entry);
}

$pre self.getStep().isDefined()
operation ExecutableNode getThroughput() : Real {
  var throughput := self.getStep().throughput.first();
  if (throughput.isDefined()) {
    var tool       := self.getActivity().getVSLTool();
    return tool.getKeyvalMap(throughput).get("value").asReal();
  } else {
    return null;
  }
}

@cached
operation ExecutableNode getWeight() : Real {
  var tool := self.getActivity().getVSLTool();
  return tool.getWeight(self.getRequiredHostDemand().get("expr"));
}

@cached
operation ExecutableNode getMinimumTime() : Real {
  var tool := self.getActivity().getVSLTool();
  var rhd := self.getRequiredHostDemand();
  return tool.getMinimumTime(rhd.get("expr"));
}

@cached
operation ExecutableNode getVariable() : String {
  var tool := self.getActivity().getVSLTool();
  return tool.getVariable(self.getRequiredHostDemand().get("expr"));
}

operation ExecutableNode getRepetitions() : Real {
  var step := self.getStep();
  if (step.isUndefined()) {
    return 1.0d;
  }

  var loopPart = self.getLoopPart();
  if (loopPart == 0) {
    -- the setup part is always run once: since the algorithm assumes that *everything* is run once per iteration,
    -- we simply scale down its repetitions
    return 1.0d / self.inStructuredNode.getRepetitions();
  }
  else if (loopPart > 0) {
    -- test, body and the rest are run once per iteration
    return 1.0d;
  }
  else {
    var tool := self.getActivity().getVSLTool();
    var value := tool.getKeyvalMap(step.rep).get("value");
    if (not value.isDefined()) {
      -- The default value is still a literal number, instead of a proper NFP
      value := step.rep;
    } 
    return value.asReal();
  }
}

operation ExecutableNode setRepetitions(newRep : Real) {
  self.getStep(true).rep := '(value=' + newRep + ', source = req)';
}

@cached
operation ExecutableNode getRequiredHostDemand() : Map {
  var tool := self.getActivity().getVSLTool();
  var step := self.getStep();
  if (step.isDefined()) {
    var req := step.hostDemand.collect(e | tool.getKeyvalMap(e)).selectOne(kv|kv.get("source") == "req");
    if (req.isDefined()) {
      return req;
    }
  }
  return Map { "expr" = "0.0 + 1.0 * " + self.getContextParameterName(), "unit" = "s", "source" = "req" };
}

-*
  OPERATIONS FOR ActivityEdge
*-
$pre not self.getStep().isDefined() or self.getStep().prob.isDefined()
$post _result.isDefined() and _result >= 0 and _result <= 1
operation ActivityEdge getProbability() : Real {
  var step := self.getStep();

  if (step.isDefined()) {
    var tool := self.getActivity().getVSLTool();
    var value := tool.getKeyvalMap(step.prob).get("value");
    if (not value.isDefined()) {
      -- The default value is still a literal number
      value = step.prob;
    }
    return value.asReal();
  } else {
    return 1.0d;
  }
}

operation ActivityEdge setProbability(newProb : Real) {
  self.getStep(true).prob := '(value=' + newProb + ', source = req)';
}

-*
  OPERATIONS FOR NamedElement
*-
operation NamedElement setThroughput(newThroughput : Real) {
  -- do nothing
}

operation NamedElement setTimeLimit(newTimeMillis : Real) {
  -- do nothing
}

operation NamedElement getContextParameterName() {
  return 'sw' + self.getName().replaceAll('\\W', '');
}

operation NamedElement getThroughput() : Real {
  return 0.0d;
}

operation NamedElement getWeight() : Real {
  return 0.0d;
}

operation NamedElement getMinimumTime() : Real {
  return 0.0d;
}

operation NamedElement getVariable() : String {
  return null;
}

operation NamedElement getRepetitions() : Real {
  return 0.0d;
}

operation NamedElement getRequiredHostDemand() : Map {
  return Map { "expr" = "0 + 0 * " + self.getContextParameterName(), "source" = "req" };
}

operation NamedElement getScenario() : GaScenario {
  return self.getScenario(false);
}

operation NamedElement getScenario(createIfMissing : Boolean) : GaScenario {
  var scenario := GaScenario.allInstances.selectOne(s|s.base_NamedElement == self);
  if (createIfMissing and scenario.isUndefined()) {
    scenario := new GaScenario;
    scenario.base_NamedElement := self;
  }
  return scenario;
}

operation NamedElement getStep() : GaStep {
  return self.getStep(false);
}

operation NamedElement getStep(createIfMissing : Boolean) : GaStep {
  -- Cache node->GaStep mapping in the activity, to avoid having to perform
  -- several linear scans when searching for the GaStep of several nodes
  var stepMap := self.getStepMap();
  if (createIfMissing and not stepMap.containsKey(self)) {
    var step := new GaStep;
    step.base_NamedElement := self;
    stepMap.put(self, step);
  }
  return stepMap.get(self);
}

operation NamedElement getAnalysisContext() : GaAnalysisContext {
  return GaAnalysisContext.allInstances.selectOne(s|s.base_NamedElement == self);
}

-* Operations for ActivityNode *-

operation ActivityNode getStepMap() : Map {
  return self.getActivity().getStepMap();
}

@cached
operation ActivityNode getActivity() {
  if (self.activity.isDefined()) {
    return self.activity;
  }
  else {
    return self.inGroup.first().getActivity();
  }
}

-* Operations for ActivityEdge *-

operation ActivityEdge getStepMap() : Map {
  return self.source.getStepMap();
}