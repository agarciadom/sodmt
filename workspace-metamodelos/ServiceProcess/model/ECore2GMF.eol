-*
  We could simply run everything outside of any operations. However,
  we wouldn't be able to reuse this code by importing it from another
  EOL script: it appears that importing a module only gives us the
  operations defined therein.
*-

var MSGFMT_METHOD := GmfMap!LabelTextAccessMethod#MESSAGE_FORMAT;
var NATIVE_METHOD := GmfMap!LabelTextAccessMethod#NATIVE;

serviceProcessMainBody(
  Sequence {
    'ProcessStartLabel', 'ProcessFinishLabel',
    'ProcessForkLabel', 'ProcessJoinLabel',
    'ProcessDecisionLabel',
    'ControlFlowConditionExternalLabel',
    'ServiceActivityAnnotationExternalLabel'},
  Sequence {
    Sequence {'ActivityPerformanceAnnotationManuallyAddedLabel',
      'manual = {0}'},
    Sequence {'PerformanceAnnotationConcurrentUsersLabel',
     'concurrentUsers = {0}', NATIVE_METHOD, '{0,number}'},
    Sequence {'PerformanceAnnotationSecsTimeLimitLabel',
     'timeLimit = {0}', NATIVE_METHOD, '{0,number}'},
    Sequence {'ProcessControlFlowLabel', '[{0}] (p = {1})',
     NATIVE_METHOD, '{0} : {1,number}'}},
  Sequence {
    'ControlFlowConditionLabel',
    'ActivityPerformanceAnnotationManuallyAddedLabel',
    'ActivityPerformanceAnnotationLabel',
    'ProcessPerformanceAnnotationLabel'},
  Sequence { 'ProcessControlFlowLabelLabel' });

setSymmetricLinkConstraintsForLinkMapping('ProcessControlFlow', 'self <> oppositeEnd');

-- Main body of the script -----------------------------------------
operation serviceProcessMainBody(uselessLabels : Collection,
                                 editViewPatterns : Collection,
                                 readOnlyLabels : Collection,
                                 defaultEmptyLabels : Collection) {
  removeUselessLabels(uselessLabels);
  defineEditAndViewPatterns(editViewPatterns);
  defineReadOnlyLabels(readOnlyLabels);
  for (label in defaultEmptyLabels) {
    setDefaultTextForLabel(label, '');
  }
}

-- Remove labels from nodes which don't need them ------------------
operation removeUselessLabels(labels : Collection) {
  for (label in labels) {
     removeLabel(label);
  }
}

-- Label edit and view patterns -------------------------------------
operation defineEditAndViewPatterns(entries : Collection) {
  for (entry in entries) {
    var labelName   := entry.at(0);
    var viewPattern := entry.at(1);
    var editMethod  := MSGFMT_METHOD;
    var editPattern := '{0}';
    if (entry.size() > 2) {
      editMethod  = entry.at(2);
      editPattern = entry.at(3);
    }

    setFeatureLabelPatterns(labelName,
                            editMethod, editPattern,
                            MSGFMT_METHOD, viewPattern);
  }
}

-- Make some labels read only ---------------------------------------
operation defineReadOnlyLabels(labels : Collection) {
  for (n in labels) {
    makeReadOnly(n);
  }
}

-- UTILITY OPERATIONS -----------------------------------------------

operation setDefaultTextForLabel(name : String, value : String) {
  GmfGraph!Label.all.selectOne(r|r.name=name).text := value;
}

operation makeReadOnly(diagramLabelName : String) {
  for (labelMapping in findLabelMappingsByName(diagramLabelName)) {
    labelMapping.readOnly := true;
  }
}

operation setFeatureLabelPatterns(diagramLabelName : String,
                                  editMethod : Any, editPattern : String,
                                  viewMethod : Any, viewPattern : String) {
  for (labelMapping in findLabelMappingsByName(diagramLabelName)) {
    labelMapping.editMethod    := editMethod;
    labelMapping.editPattern   := editPattern;
    labelMapping.editorPattern := editPattern;
    labelMapping.viewMethod  := viewMethod;
    labelMapping.viewPattern := viewPattern;
  }
}

operation removeLabel(diagramLabelName : String) {
  var diagLabels    := findDiagramLabelsByName(diagramLabelName);
  var labelMappings := findLabelMappingsByDiagramLabels(diagLabels);

  for (labelMapping in labelMappings) {
    if (labelMapping.isDefined()) {
      delete labelMapping;
    }
  }
  for (diagLabel in diagLabels) {
    if (diagLabel.accessor.isDefined()) {
      -- Composite figure: we only want to remove the child label
      delete diagLabel.accessor.figure;
      delete diagLabel.accessor;
    }
    else {
      -- The whole figure is the label: remove it
      delete diagLabel.figure;
    }
    delete diagLabel;
  }
}

operation findDiagramLabelsByName(labelName : String) : Collection {
  return GmfGraph!DiagramLabel.all.select(r|r.name = labelName);
}

operation findLabelMappingsByDiagramLabels(diagramLabels : Collection) : Collection {
  return GmfMap!LabelMapping.all.select(r|diagramLabels.includes(r.diagramLabel));
}

operation findLabelMappingsByName(diagramLabelName : String) : Collection {
  return findLabelMappingsByDiagramLabels(findDiagramLabelsByName(diagramLabelName));
}

operation findLinkMappingsByLabelMapping(labelMapping : GmfMap!LabelMapping) : Collection {
  return GmfMap!LinkMapping.all.select(r|r.labelMappings.includes(labelMapping));
}

operation findLinkMappingsByDiagramLinkName(diagLinkName : String) : Collection {
  return GmfMap!LinkMapping.all.select(r|r.diagramLink.name = diagLinkName);
}

operation setLinkConstraintsForLinkMapping(diagLinkName : String, sourceEndConstraint : String, targetEndConstraint : String) {
  var linkMapping := findLinkMappingsByDiagramLinkName(diagLinkName).first();
  linkMapping.creationConstraints := new GmfMap!LinkConstraints;
  linkMapping.creationConstraints.sourceEnd := new GmfMap!Constraint;
  linkMapping.creationConstraints.sourceEnd.body := sourceEndConstraint;
  linkMapping.creationConstraints.targetEnd := new GmfMap!Constraint;
  linkMapping.creationConstraints.targetEnd.body := targetEndConstraint;
}

operation setSymmetricLinkConstraintsForLinkMapping(diagLinkName : String, endConstraint : String) {
  return setLinkConstraintsForLinkMapping(diagLinkName, endConstraint, endConstraint);
}
