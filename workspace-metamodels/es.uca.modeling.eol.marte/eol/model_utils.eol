-*
  Accessors and mutators for MDT UML2 models annotated with the MARTE profile.

  Copyright (c) 2011 Antonio García Domínguez.  All rights
  reserved. This program and the accompanying materials are made
  available under the terms of the Eclipse Public License v1.0 which
  accompanies this distribution, and is available at
  http://www.eclipse.org/legal/epl-v10.html

  Contributors:
     Antonio García Domínguez - initial API and implementation
*-

-*
  OPERATIONS FOR Activity
*-
@cached
operation Activity getVSLTool() {
  return new Native("es.uca.modeling.eol.marte.tools.VSLTupleTool");
}

@cached
$pre self.getScenario().isDefined() and not self.getScenario().respT.isEmpty()
operation Activity getTimeLimit() : Real {
  var tool := self.getVSLTool();
  return tool.getKeyvalMap(self.getScenario().respT.first()).get("value").asReal() * 1.0d;
}

@cached
$pre self.getScenario().isDefined()
operation Activity getThroughput() : Real {
  var tool := self.getVSLTool();
  return tool.getKeyvalMap(self.getScenario().throughput.first()).get("value").asReal() * 1.0d;
}

@cached
operation Activity getAnalysisContext() : GaAnalysisContext {
  var context := GaAnalysisContext.allInstances.select(e|e.base_NamedElement == self).first();
  if (context.isDefined()) {
    return context;
  }
  else {
    var context := new GaAnalysisContext;
    context.base_NamedElement := self;
    return context;
  }
}

-- Sets the value of a slack per unit of weight variable.
operation Activity setSWVariable(name : String, value : Real) {
  var tool     := self.getVSLTool();
  var ctx      := self.getAnalysisContext().context;
  var fullExpr := "$" + name + " : Real = " + value;

  -- Search if the variable is already declared in the context.
  var iParam := 0;
  while (iParam < ctx.size()) {
    var paramName := tool.getParameterName(ctx.at(iParam));
    if (name == paramName) {
      -- The variable is already declared: replace its value and we're done.
      ctx.removeAt(iParam);
      ctx.add(iParam, fullExpr);
      return;
    }

    iParam := iParam + 1;
  }

  -- The variable was not part of the context yet: add it.
  ctx.add(fullExpr);
}

-*
  OPERATIONS FOR ExecutableNode
*-
$pre self.getStep().isDefined()
operation ExecutableNode setThroughput(newThroughput : Real) {
  var step := self.getStep();
  step.throughput.clear();
  step.throughput.add('(value=' + newThroughput + ',source=calc)');
}

$pre self.getStep().isDefined()
operation ExecutableNode getTimeLimit() : Real {
  var tool   := self.activity.getVSLTool();
  var stepHD := self.getStep().hostDemand;
  var kvCalcHD := stepHD.collect(e|tool.getKeyvalMap(e)).select(kv|kv.get("source") == "calc").first();
  if (kvCalcHD.isDefined()) {
    return kvCalcHD.get("value").asReal() * 1.0d;
  }
  else {
    return 0.0d;
  }
}

$pre self.getStep().isDefined()
operation ExecutableNode setTimeLimit(newTimeMillis : Real) {
  var tool := self.activity.getVSLTool();
  var step := self.getStep();

  -- Remove all constraints not set by the user
  step.hostDemand := step.hostDemand.select(e | tool.getKeyvalMap(e).get("source") == "req");

  -- Add a calculated constraint with the time
  step.hostDemand.add('(value=' + newTimeMillis + ',source=calc)');
}

$pre self.getStep().isDefined()
operation ExecutableNode getThroughput() : Real {
  var tool       := self.activity.getVSLTool();
  var throughput := self.getStep().throughput.first();
  if (throughput.isDefined()) {
    return tool.getKeyvalMap(throughput).get("value").asReal();
  } else {
    return null;
  }
}

@cached
operation ExecutableNode getWeight() : Real {
  var tool := self.activity.getVSLTool();
  return tool.getWeight(self.getRequiredHostDemand().get("expr"));
}

@cached
operation ExecutableNode getMinimumTime() : Real {
  var tool := self.activity.getVSLTool();
  return tool.getMinimumTime(self.getRequiredHostDemand().get("expr"));
}

@cached
operation ExecutableNode getVariable() : String {
  var tool := self.activity.getVSLTool();
  return tool.getVariable(self.getRequiredHostDemand().get("expr"));
}

@cached
operation ExecutableNode getRepetitions() : Real {
  return self.getStep().rep.asReal();
}

@cached
operation ExecutableNode getRequiredHostDemand() : Map {
  var tool := self.activity.getVSLTool();
  if (self.getStep().isDefined()) {
    return self.getStep().hostDemand.collect(e | tool.getKeyvalMap(e)).select(kv|kv.get("source") == "req").first();
  } else {
    var map : Map;
    map.put("expr", "0.0+1.0*x");
    map.put("source", "req");
    return map;
  }
}

-*
  OPERATIONS FOR ActivityEdge
*-
@cached
$pre not self.getStep().isDefined() or self.getStep().prob.isDefined()
$post _result.isDefined() and _result >= 0 and _result <= 1
operation ActivityEdge getProbability() : Real {
  var step := self.getStep();

  if (step.isDefined()) {
    return step.prob.asReal();
  } else {
    return 1.0d;
  }
}

-*
  OPERATIONS FOR NamedElement
*-
operation NamedElement setThroughput(newThroughput : Real) {
  -- do nothing
}

operation NamedElement setTimeLimit(newTimeMillis : Real) {
  -- do nothing
}

operation NamedElement getThroughput() : Real {
  return 0.0d;
}

operation NamedElement getWeight() : Real {
  return 0.0d;
}

operation NamedElement getMinimumTime() : Real {
  return 0.0d;
}

operation NamedElement getVariable() : String {
  return null;
}

operation NamedElement getRepetitions() : Real {
  return 0.0d;
}

operation NamedElement getRequiredHostDemand() : Map {
  var map : Map;
  map.put("expr", "0+0*x");
  map.put("source", "req");
  return map;
}

@cached
operation NamedElement getScenario() : GaScenario {
  return GaScenario.allInstances.select(s|s.base_NamedElement == self).first();
}

operation NamedElement getStep() : GaStep {
  -- Cache node->GaStep mapping in the activity, to avoid having to perform
  -- several linear scans when searching for the GaStep of several nodes
  if (not self.activity.~stepMap.isDefined()) {
    var map : Map;
    for (step in GaStep.allInstances) {
      map.put(step.base_NamedElement, step);
    }
    self.activity.~stepMap := map;
  }
  return self.activity.~stepMap.get(self);
}

@cached
operation NamedElement getAnalysisContext() : GaAnalysisContext {
  return GaAnalysisContext.allInstances.select(s|s.base_NamedElement == self).first();
}
