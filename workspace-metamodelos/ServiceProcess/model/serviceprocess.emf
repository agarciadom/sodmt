@namespace(uri="www.uca.es/modeling/serviceProcess", prefix="sp")
package serviceProcess;

@gmf.diagram(foo="bar")
class ServiceProcess {
  val Activity[*] activity;
  val ControlNodeEdge[*] edge;
  val GlobalPerformanceAnnotation globalPerformance;
}

@gmf.node(label="name")
abstract class NamedElement {
   attr String name;
}

abstract class Activity {
  @gmf.compartment(layout="free")
  val ActivityNode[*]#activity nodes;
}

abstract class ActivityNode {
  ref Activity#nodes activity;
}

abstract class ControlNode extends ActivityNode {
  ref ControlNodeEdge[*]#target incoming;
  ref ControlNodeEdge[*]#source outgoing;
}

@gmf.link(source="source", target="target", width="3")
abstract class ControlNodeEdge {
  ref ControlNode#incoming target;
  ref ControlNode#outgoing source;
  @gmf.link(label="condition", style="dash", tool.name="Link Edge Condition")
  ref EdgeCondition#edge condition;
}

abstract class PerformanceAnnotation {
   @gmf.label(foo="bar")
   attr Double transactionsPerSec = 1;
   @gmf.label(foo="bar")
   attr Double secsTimeLimit = 1;
}

/* ANNOTATIONS */

/* condition = 'else' -> default flow */
@gmf.node(label="language",
          label.pattern="<<{0}>>",
          figure="rectangle",
          tool.name="Edge Condition")
class EdgeCondition extends ActivityNode {
    ref ControlNodeEdge#condition edge;

    @gmf.label(foo="bar")
    attr String condition = "true";
    attr ExpressionLanguage language;
    @gmf.label(foo="bar")
    attr Double probability = 1;
}

@gmf.node(label="transactionsPerSec",
          label.pattern="<<performance>>",
          figure="rectangle",
          tool.name="Local Performance Constraint")
class LocalPerformanceAnnotation extends PerformanceAnnotation, ActivityNode {
   ref ExecutableNode#annotation execNode;
   @gmf.label(label.readOnly="true")
   attr boolean manuallyAdded = true;
}

@gmf.node(label="transactionsPerSec",
          label.pattern="<<performance>>",
          figure="rectangle",
          tool.name="Global Performance Constraint")
class GlobalPerformanceAnnotation extends PerformanceAnnotation {}

/* ACTIVITIES */

@gmf.node(tool.name="Service Activity")
class ServiceActivity extends Activity, NamedElement {}

/* EDGES */

@gmf.link(style="dash",target.decoration="arrow",tool.name="Object Flow")
class ObjectFlow extends ControlNodeEdge {
}

@gmf.link(target.decoration="arrow", tool.name="Control Flow")
class ControlFlow extends ControlNodeEdge {
}

/* NODES */

@gmf.node(figure="es.uca.modeling.figures.LabeledEllipse", label.icon="false",
          tool.name="Executable Node")
class ExecutableNode extends ControlNode, NamedElement {
  @gmf.link(label="performance", style="dash",
            tool.name="Link Performance Annotation")
  ref LocalPerformanceAnnotation#execNode annotation;
}

@gmf.node(figure="rectangle", label.icon="false", tool.name="Object Node")
class ObjectNode extends ControlNode, NamedElement {}

@gmf.node(figure="es.uca.modeling.figures.FgFilledCircleFigure", border.color="0,0,0",
          size="30,30", tool.name="Start")
class InitialNode extends ControlNode {
}

@gmf.node(figure="es.uca.modeling.figures.FgBgFilledCircleFigure", border.color="0,0,0",
          size="30,30", tool.name="Finish")
class FinalNode extends ControlNode {
}

@gmf.node(figure="es.uca.modeling.figures.FgFilledRectangleFigure", border.color="0,0,0",
          size="15,30", tool.name="Fork")
class ForkNode extends ControlNode {
}

@gmf.node(figure="es.uca.modeling.figures.FgFilledRectangleFigure", border.color="0,0,0",
          size="15,30", tool.name="Join")
class JoinNode extends ControlNode {
}

@gmf.node(figure="es.uca.modeling.figures.DiamondFigure", border.color="0,0,0", size="30,30",
          tool.name="Decision")
class DecisionNode extends ControlNode {
}

/* DATATYPES */

enum ExpressionLanguage {
   OCL;
   JML;
}

/* Visit status for nodes: needed for the colored depth-first search
   used to detect cycles in the graph in the EVL script. */
enum VisitStatus {
   NOT_VISITED;
   VISITING;
   VISITED;
}

/* Node side: useful for operations which need to distinguish between the
   incoming side and the outgoing side */
enum NodeSide {
   INCOMING;
   OUTGOING;
}
