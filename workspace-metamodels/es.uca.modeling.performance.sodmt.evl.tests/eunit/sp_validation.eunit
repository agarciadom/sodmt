@test
operation emptyModelIsNotValid() {
  new SP!ServiceProcess;
  validate();
  assertHasProblems(Sequence {
    'ExactlyOneProcessStart',
    'MinimumOneFinalNode',
    'ProcessPerformanceMustBeDefined'
  });
}

@test
operation onlyProcessStart() {
  var sp = new SP!ServiceProcess;
  sp.nodes.add(new SP!InitialNode);
  validate();

  assertNoProblems(Sequence {
    'ExactlyOneProcessStart',
    'MinimumOneIncoming', // not applicable to initial node
    'MaximumOneIncoming', // max is OK
    'MaximumOneOutgoing'  // max is OK
  });
  assertHasProblems(Sequence {
    'MinimumOneFinalNode',
    'ProcessPerformanceMustBeDefined',
    'MinimumOneOutgoing',  // initial node has no outgoing edges
    'AllPathsFromInitialNodeMustEndInFinalNode', // no valid paths
    'ProcessPerformanceMustBeDefined'
  });
}

@test
operation multipleProcessStart() {
  var sp = new SP!ServiceProcess;
  sp.nodes.add(new SP!InitialNode);
  sp.nodes.add(new SP!InitialNode);
  validate();

  assertHasProblem('ExactlyOneProcessStart');
}

@test
operation oneProcessFinish() {
  var sp = new SP!ServiceProcess;
  sp.nodes.add(new SP!FinalNode);
  validate();
  assertNoProblem('MinimumOneFinalNode');
  assertHasProblem('ExactlyOneProcessStart');
}

operation assertHasProblem(ruleName : String) {
  assertHasProblems(Sequence { ruleName });
}

operation assertNoProblem(ruleName : String) {
  assertNoProblems(Sequence { ruleName });
}

operation assertHasProblems(ruleNames : Sequence) {
  var problems = EVL!EvlUnsatisfiedConstraint.allInstances;

  for (ruleName in ruleNames) {
    if (not problems.exists(p|p.constraint.name = ruleName)) {
      if (problems.isEmpty) {
        fail("The model did not violate rule '" + ruleName + "' nor any other");
      } else {
        var problemNames = problems.collect(p|p.constraint.name).concat(",");
        fail("The model did not violate rule '" + ruleName + "', but these ones: " + problemNames);
      }
    }
  }
}

operation assertNoProblems(ruleNames : Sequence) {
  var problems = EVL!EvlUnsatisfiedConstraint.allInstances;

  for (ruleName in ruleNames) {
    assertFalse("The model should not violate rule '" + ruleName + "'", problems.exists(p|p.constraint.name = ruleName));
  }
}
