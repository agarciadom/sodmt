-*
  Script for measuring the performance of the inference algorithms
  in various situations.

  Copyright (C) 2011 Antonio García Domínguez.  All rights reserved. This
  program and the accompanying materials are made available under the terms
  of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  Contributors:
     Antonio García Domínguez - initial API and implementation
*-
import '../eol/time_limits.eol';
import '../eol/throughput.eol';

-- BASIC CONFIGURATION
-- Note: fixed/random annotations are selected by commenting some lines in the main body.

-*
var levels         := 45;
var fixed_samples  := 5;         -- fixed repetitions for random annotations
var time_per_level := 30 * 1000; -- variable repetitions for fixed annotations
var gctool := new Native("es.uca.modeling.eol.marte.tools.GCTool");
var random := new Native("java.util.Random");
random.setSeed(0l);

testPerformance(levels, fixed_samples, time_per_level, random, true);
--testPerformance(levels, fixed_samples, time_per_level, random, false);

operation testPerformance(levels, fixed_samples, time_per_level, random, fixed_repetitions) {
  if (fixed_repetitions) {
    ("Using " + levels + " level(s) with " + fixed_samples + " sample(s) each").println();
  } else {
    ("Using " + levels + " level(s) with " + time_per_level + "s for each").println();
  }
  "--".println();

  -- MAIN BODY

  for (level in 1.to(levels)) {
    gctool.gc(Model);

    var time_tlimit     := 0;
    var time_throughput := 0;
    var activity;

    var n_samples := 0;
    var loop := true;
    while (loop) {
      activity := createForkJoinActivity(level);

      -- Comment one of these two lines to select fixed or random annotations
      if (fixed_repetitions) {
        annotateRandom(activity, 1, 1, 1, random);
      } else {
        annotateFixed(activity, 1, 1, 0, 1);
      } 

      -- First inference algorithm: time limits
      var finalNodes  := activity.node.select(e : FinalNode | true);
      var t0_tlimit := getCurrentTimeMillis();
      distributeTime(1, finalNodes);
      var delta_tlimit := getCurrentTimeMillis() - t0_tlimit;
      time_tlimit := time_tlimit + delta_tlimit;

      -- Second inference algorithm: throughputs
      var initialNode := activity.node.select(e : InitialNode | true).first();
      var t0_throughput := getCurrentTimeMillis();
      annotateThroughput(initialNode);
      var delta_throughput := getCurrentTimeMillis() - t0_throughput;
      time_throughput := time_throughput + delta_throughput;

      -- Print results for this sample
      ("Sample " + (n_samples + 1) + ": "
--        + delta_tlimit + "ms for time limits, "
        + delta_throughput + "ms for throughputs"
        ).println();

      -- Delete the activity and the annotations, to keep the model small
      deleteAll(activity);
      n_samples := n_samples + 1;

      if (fixed_repetitions) {
        loop := (n_samples < fixed_samples);
      } else {
        loop := (time_tlimit < time_per_level and time_throughput < time_per_level);
      }
    }

    ("Time limits," + level + "," + time_tlimit/(n_samples * 1000.0)).println();
    ("Throughputs," + level + "," + time_throughput/(n_samples * 1000.0)).println();
  }
}*-

-- UTILITY OPERATIONS --

$pre levels >= 0
operation createForkJoinActivity(levels : Integer) : Activity {
  var activity := Model.createInstance("Activity");

  var prevNode := activity.addNode("InitialNode");
  for (level in 1.to(levels)) {
    var forkNode := activity.addNode("ForkNode");
    var joinNode := activity.addNode("JoinNode");
    var branchA  := activity.addNode("OpaqueAction");
    var branchB  := activity.addNode("OpaqueAction");

    branchA.name := "A" + level;
    branchB.name := "B" + level;
    activity.addEdge(prevNode, forkNode);
    activity.addEdge(forkNode, branchA);
    activity.addEdge(forkNode, branchB);
    activity.addEdge(branchA, joinNode);
    activity.addEdge(branchB, joinNode);

    prevNode := joinNode;
  }

  var finalNode := activity.addNode("ActivityFinalNode");
  activity.addEdge(prevNode, finalNode);
  return activity;
}

operation annotateFixed(activity, respT, throughput, default_mtime, default_weight) {
  activity.createScenario(respT, throughput);

  var action_counter := 0;
  for (action in activity.node.select(e:ExecutableNode|true)) {
    action.createStep(default_mtime, default_weight, "sw" + action_counter);
    action_counter := action_counter + 1;
  }
}

operation annotateRandom(activity, respT, throughput, max_weight, random) {
  activity.createScenario(respT, throughput);

  var action_counter := 0;
  var available_time := 0.5 * respT;
  for (forkNode in activity.node.select(e:ForkNode|true)) {
    var siblings := forkNode.outgoing.collect(e|e.target);
    var mtimeA := random.nextDouble() * available_time;
    var mtimeB := random.nextDouble() * available_time;
    available_time := available_time - mtimeA.max(mtimeB);

    siblings.first().createStep(mtimeA, random.nextDouble() * max_weight, "swA" + action_counter);
    siblings.last().createStep(mtimeB, random.nextDouble() * max_weight, "swB" + action_counter);
    action_counter := action_counter + 1;
  }
}

operation getCurrentTimeMillis() {
  var cal := new Native("java.util.GregorianCalendar");
  return cal.getTimeInMillis();
}

-*
  OPERATIONS FOR Action
*-
operation Action createStep(mtime, weight, variable) {
  var step := Model.createInstance("GaStep");
  step.base_NamedElement := self;
  step.hostDemand.add(
    "(expr=" + mtime +
    " + " + weight +
    " * " + variable +
    ", unit=s, source=req)");  
}

-*
  OPERATIONS FOR Activity
*-
operation Activity addNode(type) : ActivityNode {
  var node := Model.createInstance(type);
  self.node.add(node);
  return node;
}

operation Activity addEdge(source, target) : ActivityEdge {
  var cflow := Model.createInstance("ControlFlow");
  cflow.source := source;
  cflow.target := target;
  self.edge.add(cflow);
  return cflow;
}

operation Activity createScenario(respT, throughput) {
  var scenario := Model.createInstance("GaScenario");
  scenario.base_NamedElement := self;
  scenario.respT.add("(value=" + respT + ", unit=s, source=req)");
  scenario.throughput.add("(value=" + throughput + ", unit=Hz, source=req)");
}

operation deleteAll(activity : Activity) {
  for (node in activity.node) {
    delete node.getStep();
  }
  delete activity.getScenario(); 
  delete activity;
}
