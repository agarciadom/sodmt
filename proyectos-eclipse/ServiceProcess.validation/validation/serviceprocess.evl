-- Diagram constraints --------------------------

context ServiceProcess {
  constraint ExactlyOneInitialNode {
    check : InitialNode.all.size = 1
    message : 'There must be exactly one initial node'
  }

  constraint ExactlyOneFinalNode {
    check : FinalNode.all.size = 1
    message : 'There must be exactly one final node'
  }
}

-- Abstract class constraints -------------------

context ActivityEdge {

  constraint BothEndsDefined {
    check : self.source.isDefined() and self.target.isDefined()
    message : 'Source and target of an edge must be defined'
  }

  constraint NoCycles {
    check : self.source <> self.target
    message : 'Source and target of an edge must not be the same'
    fix {
      title : 'Remove link from model'
      do {
        delete self;
      }
    }
  }

  constraint AtLeastOneActivityNodeBetweenInitialAndFinalNodes {
    check : self.source.isTypeOf(InitialNode)
            implies not self.target.isTypeOf(FinalNode)
    message : 'There must be at least one activity node between the initial '
              + 'node and the final node'
    fix {
      title : 'Add dummy executable node'
      do {
        var newExec = new ExecutableNode;
        newExec.activity := self.source.activity;
        newExec.name := 'Do something';

        var newEdge := new ControlFlow;
        newEdge.source := newExec;
        newEdge.target := self.target;
        self.target := newExec;
      }
    }
  }
}

context ActivityNode {

  constraint NoIncomingForInitialNode {
    guard : self.isTypeOf(InitialNode)
    check : self.incoming.isEmpty
    message : 'The initial node must not have any incoming edges'
    fix {
      title : 'Remove incoming edges from initial node'
      do {
        for (e in self.incoming.clone()) {
          delete e;
        }
      }
    }
  }

  constraint NoOutgoingForFinalNode {
    guard : self.isTypeOf(FinalNode)
    check : self.outgoing.isEmpty
    message : 'The final node must not have any outgoing edges'
    fix {
      title : 'Remove outgoing edges from final node'
      do {
        for (e in self.outgoing.clone()) {
          delete e;
        }
      }
    }
  }

  -- We use two constraints for the incoming count (min, max) so we only
  -- propose the join fix in the right situations. This would be much easier if
  -- fixes had guards like in the Epsilon book, but it works.
  constraint MinimumOneIncoming {
    guard : not self.isTypeOf(JoinNode) and not self.isTypeOf(InitialNode)
    check : self.incoming.size >= 1
    message : 'All activity nodes except joins and initial nodes must have '
              + 'exactly one incoming edge'
  }

  constraint MaximumOneIncoming {
    guard : not self.isTypeOf(JoinNode) and not self.isTypeOf(InitialNode)
    check : self.incoming.size <= 1
    message : 'All activity nodes except joins and initial nodes must have '
              + 'exactly one incoming edge'
    fix {
      title : 'Add join node in the middle'
      do {
        var newJoin := new JoinNode;
        newJoin.activity := self.activity;

        var newEdge := createEdgeSimilarTo(self.incoming.first.isOfType);
        for (e in self.incoming) {
          e.target := newJoin; 
        } 
        newEdge.source := newJoin;
        newEdge.target := self;
      }
    }      
  }

  -- See above comment for an explanation of why we use both min and max
  -- constraints instead of just one
  constraint MinimumOneOutgoing {
    guard : not self.isTypeOf(ForkNode) and not self.isTypeOf(FinalNode)
    check : self.outgoing.size >= 1
    message : 'All activity nodes except forks and final nodes must have '
              + 'exactly one outgoing edge'
  }

  constraint MaximumOneOutgoing {
    guard : not self.isTypeOf(ForkNode) and not self.isTypeOf(FinalNode)
    check : self.outgoing.size <= 1
    message : 'All activity nodes except forks and final nodes must have '
              + 'exactly one outgoing edge'
    fix {
      title : 'Add fork node in the middle'
      do {
        var newFork := new ForkNode;
        newFork.activity := self.activity;
        
        var newEdge := createEdgeSimilarTo(self.incoming.first.isOfType);
        for (e in self.outgoing) {
          e.source := newFork;
        }
        newEdge.source := self;
        newEdge.target := newFork;
      }
    }
  }
}

-- Annotation constraints -------------------------

context EdgeCondition {
  constraint EdgeIsDesigned {
    check : self.edge.isDefined()
    message : 'Condition must be linked to an edge starting from a '
              + 'DecisionNode'
  }
  constraint OnlyFromDecisionNode {
    check : self.edge.source.isOfType(DecisionNode)
    message : 'Condition applied to edge which does not start from '
              + 'a DecisionNode'
  }
  constraint NonEmptyCondition {
    check : self.condition <> ''
    message : 'Condition cannot be empty'
  }
  constraint ValidProbability {
    check : self.probability > 0 and self.probability < 1
    message : 'Condition must be true with probability > 0 and < 1'
  }
}

context PerformanceAnnotation {
  constraint ValidTransactionsPerSec {
    check : self.transactionsPerSec > 0
    message : 'Transactions per sec must be a natural number'
  }
  constraint ValidTimeLimit {
    check : self.secsTimeLimit > 0
    message : 'The time limit for a single transaction must be '
              + 'greater than 0'
  }
  constraint IsLinkedToNodeOrActivity {
    check : self.execNode.isDefined() or self.activity.isDefined()
    message : 'The annotation must be linked to an Activity or an '
              + 'Executable Node'
  }
}

-- Node constraints -----------------------------

context ExecutableNode {
  constraint NameMustNotBeEmpty {
    check : self.name <> ''
    message : 'The name of an executable node must not be empty'
  }
}

operation createEdgeSimilarTo(e : ActivityEdge) {
  if (e.isOfType(ControlFlow)) {
    return new ControlFlow;
  } else {
    return new ObjectFlow;
  }
}