-- PERFORMANCE ANNOTATIONS ----------------------------------------------------

operation FlowNode hasManualPerformanceAnnotation() : Boolean {
  return self.hasProperty('annotation') and self.annotation.isDefined() and self.annotation.manuallyAdded;
}

operation FlowNode hasAutomaticPerformanceAnnotation() : Boolean {
  return self.hasProperty('annotation') and self.annotation.isDefined() and not self.annotation.manuallyAdded;
}

-- GRAPH PREPROCESSING --------------------------------------------------------

@cached
$post _result >= 0
operation FlowNode getDepth() : Integer {
  if (self.incoming.isEmpty()) {
    return 0;
  }
  else {
    return self.incoming.collect(r|r.source.getDepth()).max() + 1;
  }
}

-- LOWEST COMMON ANCESTOR -----------------------------------------------------

@cached
$pre nodeA.getDepth().isDefined() and nodeB.getDepth().isDefined()
operation getLCA(nodeA : FlowNode, nodeB : FlowNode) : FlowNode {
  var depths     := Sequence { nodeA.getDepth(), nodeB.getDepth() };
  var maxDepth   := depths.min();
  var ancestorsA := nodeA.getAncestors(maxDepth);
  var ancestorsB := nodeB.getAncestors(maxDepth);
  var common := ancestorsA.intersect(ancestorsB);

  if (common.isEmpty()) {
    return;
  }

  return common.asSequence().sortBy(r|-r.getDepth()).first();
}

$pre maxDepth >= 0
operation FlowNode getAncestors(maxDepth : Integer) : Set {
  var results := new Set;
  self.addAllAncestors(maxDepth, results);
  --results.println('ancestors of ' + self + ', which has depth = ' + self.getDepth() + ', with maxdepth = ' + maxDepth + ': ');
  return results;
}

$pre maxDepth >= 0 and results.isDefined()
operation FlowNode addAllAncestors(maxDepth : Integer, results : Collection) {
  if (self.getDepth() <= maxDepth) {
    results.add(self);
  }
  for (parent in self.incoming.collect(r|r.source)) {
    parent.addAllAncestors(maxDepth, results);
  }
}

$pre otherSet.isDefined()
operation Set intersect(otherSet : Set) : Set {
  if (otherSet.size() < self.size()) {
    return otherSet.intersect(self);
  }

  var results : Set;
  for (element in self.select(r|otherSet.includes(r))) {
    results.add(element);
  }
  return results;
}

----- ALL PATHS BETWEEN TWO NODES ---------------------------------------------

-- Obtains all the nodes reachable from a node in the graph, in no
-- particular order. Returns a Sequence, as sets cannot be sorted with sortBy.
@cached
operation FlowNode getAllReachableNodes() : Sequence {
  var nodeSet := new Set;
  nodeSet.addAll(getAllPathsFrom(self).flatten());
  var nodeList := new Sequence;
  nodeList.addAll(nodeSet);
  return nodeList;
}

-- Obtains all the paths starting from a node in the graph
-- to every final node (if the starting node is a FinalNode,
-- reports an empty set of paths)
@cached
operation getAllPathsFrom(start : FlowNode) {
  if (start.isKindOf(FinalNode)) {
    return Sequence {};
  }
  else {
    return auxPathsTo(Sequence { start });
  }
}

operation auxPathsTo(partialPath : Sequence) {
  var last_elem := partialPath.last();

  if (last_elem.isKindOf(FinalNode)) {
    return Sequence { partialPath };
  }

  var results := new Sequence;
  for (descendant in last_elem.outgoing.collect(r|r.target)) {
    var newPartialPath := partialPath.clone();
    newPartialPath.add(descendant);
    results.addAll(auxPathsTo(newPartialPath));
  }
  return results;
}
