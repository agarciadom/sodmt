import "common.eol";

@data wA
@data wB
@data wC
@data wD
operation weights() {
  return 0.to(5);
}

@data mA
@data mB
@data mC
@data mD
operation minTimes() {
  return Sequence {0, 30, 60};
}

@model
operation createModel() {
  var sp = new ServiceProcess;

  var start = new ProcessStart;
  var decAB = new ProcessDecision;
  var decCD = new ProcessDecision;
  var mrgAB = new ProcessJoin;
  var mrgCD = new ProcessJoin;
  var fin = new ProcessFinish;
  sp.nodes.add(start);
  sp.nodes.add(decAB); sp.nodes.add(mrgAB);
  sp.nodes.add(decCD); sp.nodes.add(mrgCD);
  sp.nodes.add(fin);

  var nodeA = createActivity(sp, "A", wA, mA);
  var nodeB = createActivity(sp, "B", wB, mB);
  var nodeC = createActivity(sp, "C", wC, mC);
  var nodeD = createActivity(sp, "D", wD, mD);

  createEdge(sp, start, decAB);
  createDiamondEdges(sp, decAB, nodeA, nodeB, mrgAB);
  createEdge(sp, mrgAB, decCD);
  createDiamondEdges(sp, decCD, nodeC, nodeD, mrgCD);
  createEdge(sp, mrgCD, fin);
}

@test
operation correctResults() {
  var globalLimit := 200;
  var epsilon     := 0.0001;
  var startNode   := getStartNode();
  annotateTimeLimits(globalLimit, startNode);
  for (path in getAllPathsFrom(startNode)) {
    var total := path.collect(a:ServiceActivity | a.getTimeLimit()).sum;
    if (total > globalLimit + epsilon) {
      fail("Total was " + total + ", which is greater than " + globalLimit);
    }
  }
}

operation getStartNode() {
  return FlowNode.allInstances.select(e|e.incoming.isEmpty()).first();
}

operation createActivity(sp : ServiceProcess, name : String, weight : Real, minLimit : Real) : ServiceActivity {
  var node = new ServiceActivity;
  node.name = name;
  node.createPerformanceAnnotation();
  node.annotation.manuallyAdded := true;
  node.annotation.weight      := weight.asReal();
  node.annotation.minimumTime := minLimit.asReal();
  sp.nodes.add(node);
  return node;
}

operation createEdge(sp, source, target) : ProcessControlFlow {
  var edge = new ProcessControlFlow;
  edge.source := source;
  edge.target := target;
  sp.edges.add(edge);
  return edge;
}

operation createDiamondEdges(sp, decision, nodeA, nodeB, merge) : Sequence {
  return Sequence {
  	createEdge(sp, decision, nodeA),
  	createEdge(sp, decision, nodeB),
  	createEdge(sp, nodeA, merge),
  	createEdge(sp, nodeB, merge)
  };
}
